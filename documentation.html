<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Documentation - QIClib</title>
    <link rel="icon" href="qic.png" type="image/png">
    <meta name="author" content="Titas Chanda" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <meta name="robots" content="noindex">
    <meta name="googlebot" content="noindex">
  </head>
  <body>
    <section class="page-header">
      <img src="qic.png" alt="QIClib logo" style="width:80px;height:80px;">
      <h1 class="project-name">Quantum Information and Computation library <br> (QIClib)</h1>
      <h2 class="project-tagline">A C++11 library for quantum information and computation based on Armadillo</h2>
      <a href="index.html" class="btn">Home</a>
      <a href="documentation.html" class="btn">API Documentation</a>
      <a href="sample.html" class="btn">Sample Codes</a>
      <br>
      <a href="https://github.com/titaschanda/QIClib" class="btn">View on <br> GitHub</a>
      <a href="https://github.com/titaschanda/QIClib/archive/v0.0.4.3.zip" class="btn">Download .zip <br> v1.0.0</a>
      <a href="https://github.com/titaschanda/QIClib/archive/v0.0.4.3.tar.gz" class="btn">Download .tar.gz <br> v1.0.0</a>

    </section>

    <section class="main-content">
      
      <a name=top></a>  
      <center><h2> API Reference for QIClib 0.0.4
      </h2></center>

      
      <b>Preamble</b>
      <br>
      
      <tr>
	<td style="text-align: left; vertical-align: top; width: 50%;">
	  <ul>
	    <br>
	    <li>
	      Every functions, classes, or constants in QIClib belongs to the <code> namespace qic</code>.
	    </li>
	    <br>
	    <li>
	      First time users may want to have a look on  <a href="sample.html#samples">sample programs</a>.
	    </li>
	    <br>
	    <li>
	      First time users may want to have a look on  <a href="#faq">frequently asked questions</a>.
	    </li>
	    <br>
	    <li>
	      If you discover any bugs or regressions, please <a href="index.html#found-an-issue-or-bug">report them</a>
	    </li>
	    <br>
	    <li>
	      Notes on <a href="#api_additions">API additions</a>
	    </li>
	  </ul>
	</td>
	<td>

	  <br>


	  <b>Overview</b><br>
	  <ul>
	    <li><a href="#classes">Classes and constants</a></li>
	    <li><a href="#functions">Functions</a></li>
	    <li><a href="#discord_func">Classes for quantum discord like features</a></li>
	    <li><a href="#macro">Preprocessor macros to tune the library in compile time</a></li>
	  </ul>
	  <br>


	  <a name="classes"></a>
	  <b>Classes and constants</b><br>
	  <ul>
	    <table>
	      <tbody>
		<!--		<tr><td><a href="#eps"> _precision::eps     </td><td>  </td><td> Precision for floating point arithmetic</td></tr>
		  -->		
		<tr><td><a href="#init"> Init     </td><td>  </td><td> Class for library initialization</td></tr>
		
		<tr><td><a href="#spm"> SPM&lt;POD_TYPE&gt;, spm, spmf</a>  </td><td>  </td><td> Several predefined constant special 
		    matrices like basis states, projectors and operators</td></tr>

  		<tr><td><a href="#gates"> GATES&lt;POD_TYPE&gt;, gates, gatesf</a>  </td><td>  </td><td> Several predefined 
  		    constant quantum gates and generators of quantum gate</td></tr>

		
		<tr><td><a href="#func"> Func&lt;POD_TYPE&gt;, func, funcf  </td><td>  </td><td> Several predefined functions to be 
		    used with <code><a href = #funcm_sym>funcm_sym</a></code> or <code><a href = #funcm_gen>funcm_gen</a></code>
		    
		</td></tr>
		<tr><td><a href="#RandomDevices"> RandomDevices, rdevs</td><td>  </td><td> Predefined random number 
		    engines/generators, used in functions like <a href="#randU">randU</a> etc.
		</td></tr>

		
	      </tbody>
	    </table>
	  </ul>
	  <br>



	  <a name="functions"></a>
	  <b>Functions</b><br>
	  <ul>
	    <table>
	      <tbody>
		<tr><td><a href="#is_Hermitian"> is_Hermitian </a> </td><td>  </td><td> Hermiticity check</td></tr>
		
		<tr><td><a href="#is_Unitary"> is_Unitary </a> </td><td>  </td><td> Unitarity check</td></tr>
		
		<tr><td><a href="#is_Normal"> is_Normal </a> </td><td>  </td><td> Check whether the the matrix is 
		    normal or not</td></tr>
		
		<tr><td><a href="#is_pure"> is_pure </a> </td><td>  </td><td> Check purity of a density matrix</td></tr>
		
		<tr><td><a href="#is_valid_state"> is_valid_state </a> </td><td>  </td><td> Check whether the matrix 
		    represents a valid quantum state</td></tr>

		<tr><td><a href="#is_diagonalizable"> is_diagonalizable </a> </td><td>  </td><td> Check whether the matrix 
		    is diagonalizable or not</td></tr>

		<tr><td><a href="#is_equal"> is_equal </a> </td><td>  </td><td> Check whether two matrices are equal</td></tr>

		<tr><td><a href="#dense_to_sparse"> dense_to_sparse </a> </td><td>  </td><td> Convert a dense matrix 
		    (<a href="http://arma.sourceforge.net/docs.html#Mat">Mat</a>) to a sparse 
		    (<a href="http://arma.sourceforge.net/docs.html#SpMat">SpMat</a>) matrix</td></tr>
		
		<tr><td><a href="#sparse_to_dense"> sparse_to_dense </a> </td><td>  </td><td> Convert a sparse matrix 
		    (<a href="http://arma.sourceforge.net/docs.html#SpMat">SpMat</a>) to a dense
		    (<a href="http://arma.sourceforge.net/docs.html#Mat">Mat</a>) 
		    matrix</td></tr>
		
		<tr><td><a href="#range"> range </a> </td><td>  </td><td> Similar to Python's range() function. 
		    Useful in range-based for loops</td></tr>


		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>


		<tr><td><a href="#TrX"> TrX </a> </td><td>  </td><td> Partial trace</td></tr>
		
		<tr><td><a href="#Tx"> Tx </a> </td><td>  </td><td> Partial transpose</td></tr>

		<tr><td><a href="#sysperm"> sysperm </a> </td><td>  </td><td> Permute subsystems of a quantum state</td></tr>
		
		<tr><td><a href="#sqrtm_sym"> sqrtm_sym </a> </td><td>  </td><td>Principal square root of matrix for 
		    real symmetric or Hermitian matrices</td></tr>

		<tr><td><a href="#sqrtm_gen"> sqrtm_gen </a> </td><td>  </td><td>Principal square root of matrix 
		    for general square matrices</td></tr>
		
		<tr><td><a href="#powm_sym"> powm_sym </a> </td><td>  </td><td>Matrix power for real symmetric 
		    or Hermitian matrices</td></tr>
		
		<tr><td><a href="#powm_gen"> powm_gen </a> </td><td>  </td><td>Matrix power for general square 
		    matrices</td></tr>
		
		<tr><td><a href="#expm_sym"> expm_sym </a> </td><td>  </td><td>Matrix exponential for real symmetric 
		    or Hermitian matrices</td></tr>
		
		<tr><td><a href="#expm_gen"> expm_gen </a> </td><td>  </td><td>Matrix exponential for general 
		    square matrices</td></tr>

		<tr><td><a href="#funcm_sym"> funcm_sym </a> </td><td>  </td><td>Matrix function for real symmetric 
		    or Hermitian matrices</td></tr>

		<tr><td><a href="#funcm_gen"> funcm_gen </a> </td><td>  </td><td>Matrix function for 
		    general square matrices</td></tr>

		<tr><td><a href="#tensor"> tensor </a> </td><td>  </td><td> Tensor product of 
		    arbitrary no. of matrices</td></tr>

		<tr><td><a href="#tensor_pow"> tensor_pow </a> </td><td>  </td><td>Tensor product power</td></tr>	
		
		<tr><td><a href="#dsum"> dsum </a> </td><td>  </td><td> Direct sum of arbitrary no. of  matrices</td></tr>
		
		<tr><td><a href="#dsum_pow"> dsum_pow </a> </td><td>  </td><td>Direct sum power</td></tr>		
		
		<tr><td><a href="#absm"> absm </a> </td><td>  </td><td>Matrix absolute value of a square matrix</td></tr>
		
		<tr><td><a href="#schatten"> schatten </a> </td><td>  </td><td>Schatten p-norm of a matrix</td></tr>
		
		<tr><td><a href="#purify"> purify </a> </td><td>  </td><td>Minimal purification of a density matrix</td></tr>
		
		<tr><td><a href="#gram_schmidt"> gram_schmidt </a> </td><td>  </td><td>Modified Gram-Schmidt orthogonalization</td></tr>
		
		<tr><td><a href="#conv_to_pure"> conv_to_pure </a> </td><td>  </td><td>Convert density matrix of a 
		    pure state to a column vector</td></tr>

		<tr><td><a href="#std_to_HS"> std_to_HS </a> </td><td>  </td><td>Convert 2-qubit density matrix 
		    from the standard basis to the Hilbert-Schmidt basis </td></tr>
		
		<tr><td><a href="#HS_to_std"> HS_to_std </a> </td><td>  </td><td>Convert 2-qubit density matrix from 
		    the Hilbert-Schmidt basis back to the standard basis</td></tr>
		
		<tr><td><a href="#mket"> mket </a> </td><td>  </td><td> Generate multipartite qudit pure state </td></tr>
		<tr><td><a href="#mproj"> mproj </a> </td><td>  </td><td> Genearte multipartite qudit projector </td></tr>


		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>


		<tr><td><a href="#randU"> randU </a> </td><td>  </td><td> Generate object with random values 
		    (uniform distribution)</td></tr>

		<tr><td><a href="#randN"> randN </a> </td><td>  </td><td> Generate object with random values 
		    (normal distribution)</td></tr>

		<tr><td><a href="#randI"> randI </a> </td><td>  </td><td> Generate object with random integers</td></tr>
		
		<tr><td><a href="#randHermitian"> randHermitian </a> </td><td>  </td><td> Generate random Hermitian 
		    matrix</td></tr>

		<tr><td><a href="#randUnitary"> randUnitary </a> </td><td>  </td><td> Generate random unitary matrix</td></tr>
		
		<tr><td><a href="#randPsi"> randPsi </a> </td><td>  </td><td> Generate random pure states</td></tr>
		
		<tr><td><a href="#randRho"> randRho </a> </td><td>  </td><td> Generate random mixed states</td></tr>

		<tr><td><a href="#randPerm"> randPerm </a> </td><td>  </td><td> Generate random permutation of unsigned integers</td></tr>


		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>



		<tr><td><a href="#entropy"> entropy </a> </td><td>  </td><td>von Neumann entropy of a quantum state</td></tr>
		
		<tr><td><a href="#shannon"> shannon </a> </td><td>  </td><td>Shannon entropy of a probability distribution</td></tr>

		<tr><td><a href="#renyi"> renyi </a> </td><td>  </td><td>Renyi entropy of a quantum state</td></tr>

		<tr><td><a href="#renyi_prob"> renyi_prob </a> </td><td>  </td><td>Renyi entropy of a probability 
		    distribution</td></tr>

		<tr><td><a href="#tsallis"> tsallis </a> </td><td>  </td><td>Tsallis entropy of a quantum state</td></tr>

		<tr><td><a href="#tsallis_prob"> tsallis_prob </a> </td><td>  </td><td>Tsallis entropy of a probability distribution</td></tr>

		<tr><td><a href="#mutual_info"> mutual_info </a> </td><td>  </td><td>Quantum mutual information between 2 
		    subsystems of a quantum state</td></tr>

		<tr><td><a href="#rel_entropy"> rel_entropy </a> </td><td>  </td><td> Relative entropy between two quantum states</td></tr>

		<tr><td><a href="#rel_entropy_prob"> rel_entropy_prob </a> </td><td>  </td><td> Relative entropy between two 
		probability distributions</td></tr>


		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>


		<tr><td><a href="#entanglement"> entanglement </a> </td><td>  </td><td>Entanglement entropy of a pure 
		    quantum state</td></tr>

		<tr><td><a href="#neg"> neg </a> </td><td>  </td><td> Negativity of a quantum state</td></tr>
		
		<tr><td><a href="#log_neg"> log_neg </a> </td><td>  </td><td>Logarithmic negativity of a quantum state</td></tr>

		<tr><td><a href="#concurrence"> concurrence </a> </td><td>  </td><td>Concurrence of a two-qubit 
		    quantum state</td></tr>

		<tr><td><a href="#EoF"> EoF </a> </td><td>  </td><td>Entanglement of formation of a two-qubit 
		    quantum state</td></tr>

		<tr><td><a href="#ent_check_CMC"> ent_check_CMC </a> </td><td>  </td><td> Check if a bipartite state 
		    is entangled or not (based on covariant matrix formulation, can be used to detect bound entangled states)</td></tr>
		
		<tr><td><a href="#schmidt"> schmidt, schmidt_full </a> </td><td>  </td><td> Schmidt decomposition of a 
		    bipartite pure state</td></tr>

		<tr><td><a href="#schmidt_base"> schmidtA, schmidtB, schmidtAB,
		      schmidtA_full, schmidtB_full, schmidtAB_full </a> </td><td>  </td><td> Schmidt vectors of a bipartite pure state</td></tr>
		

		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>


		<tr><td><a href="#l1_coh"> l1_coh </a> </td><td>  </td><td>l1-norm coherence of a quantum state</td></tr>

		<tr><td><a href="#rel_entropy_coh"> rel_entropy_coh </a> </td><td>  </td><td>Relative entropy of coherence of a 
		quantum state</td></tr>
		

		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>


		<tr><td><a href="#HS_dist"> HS_dist </a> </td><td>  </td><td>Hilbert-Schmidt distance between
		    two density matrices</td></tr>	      

		<tr><td><a href="#tr_dist"> tr_dist </a> </td><td>  </td><td>Trace distance between two density matrices</td></tr>
		
		<tr><td><a href="#HS_dist"> bures_dist </a> </td><td>  </td><td>Bures distance between two density matrices</td></tr>

		<tr><td><a href="#HS_dist"> fidelity </a> </td><td>  </td><td>Fidelity between two density matrices</td></tr>
		

		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>


		<tr><td><a href="#apply"> apply </a> </td><td>  </td><td>Apply a gate to a quantum state</td></tr>	      
		
		<tr><td><a href="#apply_ctrl"> apply_ctrl </a> </td><td>  </td><td>Apply a controlled-gate to 
		    a quantum state</td></tr>

		<tr><td><a href="#measure"> measure </a> </td><td>  </td><td>Measure a state using a set of Kraus 
		    or projection operators</td></tr>

		<tr><td><a href="#measure_comp"> measure_comp </a> </td><td>  </td><td>Measure a state in the 
		    computational basis</td></tr>



	      </tbody>
	    </table>
	  </ul>
	  <a href="#top">Go to top</a>
	  <br><br>



	  <a name="discord_func"></a>
	  <b>Classes for discord like features</b><br>
	  <ul>
	    <li> <b>Note:</b> These features depend on <a href = "http://ab-initio.mit.edu/wiki/index.php/NLopt">NLopt</a>. </li> 
	    <li> <b>Note:</b> If you want to use old API's for discord like function, define <code>QICLIB_USE_OLD_DISCORD</code> macro 
	    before including <code>QIClib</code> header. See  <a href="#macro">preprocessor macros in QIClib</a> for details. Old API's for 
	    discord like functions are not maintained anymore.</li> <br>
	    
	    <table>
	      <tbody>

		<tr><td><a href="#discord_space"> discord_space </a> </td><td>  </td><td> Computational space for calculating quantum discord
		(actual as well as constrained regular) for quantum states when measurement is done over a qubit or qutrit system</td></tr>
		    
		<tr><td><a href="#deficit_space"> deficit_space </a> </td><td>  </td><td> Computational space for calculating quantum work
		deficit (actual as well as constrained regular) for quantum states when measurement is done over a qubit or 
		qutrit system</td></tr>
		
	      </tbody>
	    </table>
	  </ul>
	  <a href="#top">Go to top</a>
	  <br><br>





	  <hr><hr>

	  In this documentation the <i>mat</i>, <i>cx_mat</i>, <i>vec</i>, and <i>cx_vec</i>  type is used for convenience. 
	  But every function should also work with <i>float</i> counterparts, like <i>fmat</i>, <i>cx_fmat</i>, <i>fvec</i>, and <i>cx_fvec</i>.

	  <hr><hr>

	  <h3>Classes and constants</h3>
	  <hr> <br>


<!--	  <a name="eps"></a>
	  <b>_precision::eps</b><br><br>
	  <ul>
	    <li>Precision for floating point arithmetic. </li><br> 
	    <li>For floating point arithmetics, every <code>float</code> or <code>double</code> <i>less than</i> 
	      <code>_precision::eps&lt;float&gt;::value</code> or <code>_precision::eps&lt;double&gt;::value</code> will be treated as zero.</li><br>
	    
	    <li> Default value for <code>_precision::eps&lt;float&gt;::value</code> is <code>10*std::numeric_limits&lt;float&gt;::epsilon()</code>, 
	      and <code>_precision::eps&lt;double&gt;::value</code> is <code>100*std::numeric_limits&lt;float&gt;::epsilon()</code>. 
	      It can be changed by editing <code>include/QIClib_bits/class/constants.hpp</code> file.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>
-->

	  <a name=init></a>
	  <b>Init</b><br><br>
	  <ul>
	    <li>Class for library initialization. Automatically loaded if you use this library. </li>

	    <li>Prints current time and date upon program start. After program completion, prints current time and date
	    along with total runtime.</li>

	    <li>To disable this feature, define <code>QICLIB_NO_INIT_MESSAGE</code> macro before including <code>QIClib</code> header.
	    See  <a href="#macro">preprocessor macros in QIClib</a> for details.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="spm"></a>
	  <b>SPM&lt;POD_TYPE&gt;<br> spm <br> spmf</b><br><br>
	  <ul>
	    <li> Several predefined special matrices and vectors like, basis, projectors, operators etc. 
	      <code>POD_TYPE</code> can be either <code>double</code> or <code>float</code>.</li><br>

	    <li> This is a singleton class, can be constructed only once. 
				You can only take <code>const</code> reference of this class using <code>SPM&lt;POD_TYPE&gt;::get_instance()</code>
				function (see below). For the ease of use, QIClib library automatically instantiates this class for <code>double</code> and
				<code>float</code> as <code>spm</code> and <code>spmf</code> respectively. Use of <code>spm</code> or <code>spmf</code>
				is recommended rather than explicit <code>SPM&lt;POD_TYPE&gt;::get_instance()</code>.</li><br>
	     <!--
	      Instantiated by <code>static const SPM&lt;double&gt;& spm  = SPM&lt;double&gt;::get_instance();</code> for 
	      <code>double</code> or <code>static const SPM&lt;float&gt;& spmf  = SPM&lt;float&gt;::get_instance();</code> for
	      <code>float</code>. You don't need to do this as it is automatically instantiated if you use this library. Just use <code>spm</code> or <code>spmf</code> (see below). </li><br>
-->
	    <li> <code>spm.S</code> gives <code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> 
	      of Pauli matrices as constant complex matrices (<code>const cx_mat</code>). <code>spm.S(0)</code>, 
	      <code>spm.S(1)</code>, <code>spm.S(2)</code>, and <code>spm.S(3)</code> are respectively <i>I<sub>2x2</sub></i>, 
	      <i> &sigma;<sub>x</sub></i>, <i> &sigma;<sub>y</sub></i>, and <i> &sigma;<sub>z</sub></i>.
	      <br>(Similarly for <code>spmf.S</code>.)</li><br>

	    <li> <code>spm.basis2</code> gives <code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> of 
	      2-dimensional basis vectors as constant complex column vectors (<code>const cx_vec</code>). <code>spm.basis2(0, i)</code> 
	      and <code>spm.basis2(1, i)</code> 
	      are respectively |0&gt and |1&gt in <i>i</i> direction <i>(i = 0, 1, 2, 3)</i>. <br>
	      <code>spm.proj2</code> gives corresponding projectors as constant complex matrices (<code>const cx_mat</code>). 
	      <br>(Similarly for <code>spmf.basis2</code> and <code>spmf.proj2</code>.)</li><br>

	    <li> <code>spm.basis3</code> gives <code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> of 
	      3-dimensional basis vectors constant complex column vectors (<code>const cx_vec</code>). <code>spm.basis3(0, i)</code>, 
	      <code>spm.basis3(1, i)</code> and 
	      <code>spm.basis3(2, i)</code> are respectively |0&gt, |1&gt and |2&gt in <i>i</i> direction <i>(i = 0, 1, 2, 3)</i>. 
	      <br><code>spm.proj3</code> gives corresponding projectors constant complex matrices (<code>const cx_mat</code>). 
	      <br>(Similarly for <code>spmf.basis3</code> and <code>spmf.proj3</code>.)</li><br>

		 <li> <code>spm.bell.phim</code>, <code>spm.bell.phip</code>, <code>spm.bell.psim</code>, and <code>spm.bell.psip</code>
				give four Bell states as constant real vectors (<code>const vec</code>).				
				<br>(Similarly for <code>spmf.bell</code>.)</li><br>				
				
	    <li> <b>Note:</b> You cannot take a copy of the whole <code>SPM&lt;POD_TYPE&gt;</code> class, but you can take reference to
	    	<code>const</code>. For this use <code>const SPM&lt;POD_TYPE&gt;& SOMENAME  = SPM&lt;POD_TYPE&gt;::get_instance();</code>.
	    	However, for each member variables, like <code>S</code> or <code>proj3</code> etc., you can either take a copy or reference 
	      to <code>const</code> (See the following example).
	      <br>
	      <br><font color="blueviolet"><i><b>Note</b>: Taking copy or reference to <code>const</code> is not advisable for the 
	      member variables. Direct use of member variables is recommended.</i></font></li><br> 


	    <li> Example:
	      <pre> 
	  	const SPM&lt;double&gt;& myspm 
   	 	   = SPM&lt;double&gt;::get_instance(); // take const ref of the whole class
	   
		const cx_mat& S1 = spm.S(1);   // \sigma_x matrix, take reference
		cx_mat S2 = spm.S(2);          // \sigma_y matrix, take a copy

		const cx_vec& plus = spm.basis2(0, 1);     // |+&gt state
		const cx_mat& proj_plus = spm.proj2(0, 1); // |+&gt&lt+| projector

		const cx_vec& U = spm.basis3(0, 3); // 1st eigenvector of 
                //Spin S_z operator in 3-dim

		const cx_mat& M = spm.basis3(1, 3); // 2nd eigenvector of 
                //Spin S_z operator in 3-dim
	
		const cx_mat& M = spm.basis3(2, 3); // 3rd eigenvector of 
                //Spin S_z operator in 3-dim
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>




	  <a name="gates"></a>
	  <b>GATES&lt;POD_TYPE&gt;<br> gates <br> gatesf</b><br><br>
	  <ul>
	    <li> Several predefined constant quantum gates and generators of quantum gates. 
	      <code>POD_TYPE</code> can be either <code>double</code> or <code>float</code>.</li><br>

	    <li> This is a singleton class, can be constructed only once. 
				You can only take <code>const</code> reference of this class using <code>GATES&lt;POD_TYPE&gt;::get_instance()</code>
				function (see below). For the ease of use, QIClib library automatically instantiates this class for <code>double</code> and
				<code>float</code> as <code>gates</code> and <code>gatesf</code> respectively. Use of <code>gates</code> or 
				<code>gatesf</code> is recommended rather than explicit <code>GATES&lt;POD_TYPE&gt;::get_instance()</code>.</li><br>
	     
	    <li> <code>gates.X</code>, <code>gates.Y</code>, <code>gates.Z</code>, and <code>gates.Had</code> give Pauli X,Y, and Z and 
	    Hadamard gates respectively. <code>gates.Y</code> is a constant complex matrix (<code>const cx_mat</code>), 
	    where as others are constant real matrices (<code>const mat</code>). 
	    <br>(Similarly for <code>gatesf.X</code>, <code>gatesf.Y</code>, <code>gatesf.Z</code>, and <code>gatesf.Had</code>.)</li><br> 
	    
		 <li> <code>gates.CNOT</code>, <code>gates.CZ</code> and <code>gates.swap</code> give controlled NOT, controlled Pauli Z,
		 and swap gates respectively as constant real matrices (<code>const mat</code>).
	    <br>(Similarly for <code>gatesf.CNOT</code>, <code>gatesf.CZ</code>, and <code>gatesf.swap</code>.)</li><br> 	    
	    
		 <li> <code>gates.Tof</code> and <code>gates.Fred</code> give Toffoli and Fredkin gates respectively as constant 
		 real matrices (<code>const mat</code>).
	    <br>(Similarly for <code>gatesf.Tof</code> and <code>gatesf.Fred</code>.)</li><br> 	    
	    	    
	    
	    <li> <code>gates.U2(theta, unitV)</code>: Generates a member of U(2) group. <code>theta</code> is a <code>double</code>
			and <code>uniV</code> is a 3-dimensional unit column vector (<code>vec</code>). Output is a fixed size 2x2 complex 
			unitary matrix (<code>cx_mat22</code>) as <i>U = cos(theta/2) I + i sin(theta/2)(unitV.&sigma;)</i>. 
			<br>(Similarly for <code>gatesf.U2(theta, unitV)</code>.)</li><br>

		
		 <li> <code>gates.qft(dim)</code>: Generates unitary matrix for quantum Fourier transform of dimension 
		 specified by <code>dim</code>, as complex matrix (<code>cx_mat</code>). 
		 <br>(Similarly for <code>gatesf.qft(dim)</code>.)</li><br>
		 
		 
<!--		 <li> <code>gates.make_ctrl(U, ctrl, subsys, dim)</code>: Convert a quantum gate <code>U</code> (<code>mat</code> 
		 or <code>cx_mat</code>) into a controlled quantum gate, where <code>subsys</code> is a <code>uvec</code> containing the indices
		  of subsystems where <code>U</code> will be applied (target subsystems), and <code>ctrl</code> is a <code>uvec</code> 
		  containing the indices of control subsystems. <code>dim</code> is a <code>uvec</code> containing the dimensions of all subsystems.
		  <br><b>Note:</b> Indices in <code>subsys</code> and <code>ctrl</code> start from 1, i.e., 
		  first party has the index 1, second party has the index 2 and so on.
		  <br><b>Note:</b> Return type is same as that of <code>U</code>.
		  <br>(Similarly for <code>gatesf.make_ctrl(U, ctrl, subsys, dim)</code>.) </li><br>
		 
		 <li> <code>gates.make_ctrl(U, ctrl, subsys, n, dim = 2)</code>: Same as above.
			Here <code>n</code> specifies the total number of subsystems, and every subsystem has same dimension specified by <code>dim</code>
			(optional, by default it is 2). <code>n</code> and <code>dim</code> both are 
			<code><a href="http://arma.sourceforge.net/docs.html#uword">uword</a></code>.
			<br>(Similarly for <code>gatesf.make_ctrl(U, ctrl, subsys, n, dim = 2)</code>.) </li><br>
-->		 
		 		
	    <li> <b>Note:</b> You cannot take a copy of the whole <code>GATES&lt;POD_TYPE&gt;</code> class, but you can take reference to
	    	<code>const</code>. For this use <code>const GATES&lt;POD_TYPE&gt;& SOMENAME  = GATES&lt;POD_TYPE&gt;::get_instance();</code>.
	    	However, for each member variables, like <code>Had</code> or <code>CNOT</code> etc., you can either take a copy or reference 
	      to <code>const</code>. Member functions like <code>U2</code> or <code>qft</code> etc. behave like 
	      normal functions. (See the following example).
	      <br>
	      <br><font color="blueviolet"><i><b>Note</b>: Taking copy or reference to <code>const</code> is not advisable for the 
	      member variables. Direct use of member variables is recommended.</i></font></li><br> 


	    <li> Example:
	      <pre> 
	  	const GATES&lt;double&gt;& mygates 
   	 	   = GATES&lt;double&gt;::get_instance(); // take const ref of the whole class
	   
		const mat& XX = gates.X;   // \sigma_x matrix, take reference
		cx_mat YY = gates.Y;       // \sigma_y matrix, take a copy

		cx_mat Q = gates.qft(8); // quantum Fourier transform 
		                         // for 8 dimension 
	<!--	mat CXX 
		    = make_ctrl(gates.X,{1},{2},{2,2}); // make control Pauli X gate 
		                                        // where control qubit is 1
		                                        // and target qubit is 2
													 
		mat CXX2 = make_ctrl(gates.X,{1},{2},2,2); // same as above
		mat CXX3 = make_ctrl(gates.X,{1},{2},2);   // same as above
		                                           // default dim = 2 is taken
	-->  </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>
	  <hr><br>





	  <a name=func></a>
	  <b>Func&lttype&gt<br> func <br> funcf</b><br><br>
	  <ul>
	    <li> Class with several predefined static member functions to be used with <code><a href = "#funcm_sym">funcm_sym</a></code> or 
	      <code><a href = "#funcm_gen">funcm_gen</a></code>.</li><br>
	    
	    <li> <code>func</code> is an alias for <code>Func&lt;double&gt;</code> and <code>funcf</code> is an alias for 
	      <code>Func&lt;float&gt;</code>.</li><br>
	    
	    <li> Every member function takes one <i>complex</i> type and returns one <i>complex</i> type.</li><br>
	    
	    <li> List of member functions:
	      <ul>
		<li> func::sin</li>
		<li> func::cos</li>
		<li> func::tan</li><br>
		<li> func::asin</li>
		<li> func::acos</li>
		<li> func::atan</li><br>
		<li> func::sinh</li>
		<li> func::cosh</li>
		<li> func::tanh</li><br>
		<li> func::asinh</li>
		<li> func::acosh</li>
		<li> func::atanh</li><br>
		<li> func::sqrt</li>
		<li> func::log</li>
		<li> func::log2</li><br>
		<li> func::real</li>
		<li> func::imag</li>
		<li> func::norm</li><br>
	      </ul>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr><br>


	  <a name="RandomDevices"></a>
	  <b>RandomDevices<br>rdevs</b><br><br>
	  <ul>
	    <li> Predefined random number engines/generators, used in functions like <a href="#randU">randU</a> etc. 
	    This class is thread safe.</li><br>

		<li>  This is a singleton class, can be constructed only once. 
				You can only take reference of this class using <code>RandomDevices::get_thread_local_instance()</code>
				or <code>RandomDevices::get_instance()</code>, <font color="blueviolet"><i>but this is not advisable at all</i></font>.
				QIClib library automatically instantiates this class as <code>redvs</code>.
				Use <code>rdevs</code> rather than explicit  <code>RandomDevices::get_thread_local_instance()</code> or
				<code>RandomDevices::get_instance()</code>.</li><br>

	    <li>There are two member variables, <code>rd</code> and <code>rng</code>. <code>rd</code> is an instance of 
	    <code>std::random_device</code>, and <code>rng</code> is an instance of Mersenne twister engine, <code>std::mt19937_64</code> 
	    or <code>std::mt19937</code> depending on whether <a href="http://arma.sourceforge.net/">Armadillo</a> uses 64bit integers or 
	    not. See <a href="http://arma.sourceforge.net/docs.html#uword">this</a>. </li><br>

	    <li> By default <code>rng</code> is seeded with the random return value of <code>rd</code>. To seed <code>rng</code> with user defined
	      value, use <code>rdevs.set_seed(YOUR_SEED)</code>. To seed <code>rng</code> with the random return value of <code>rd</code> again, use
	      <code>rdevs.set_seed_random()</code>.</li><br>

	    <li> Example:
	      <pre>
		std::cauchy_distribution&lt;double&gt; dis(0,1);
		// Cauchy distribution with parameters 0 and 1

		double a[10], b[10], c[10];

		// seed is random, by default
		for(int i = 0; i < 10; ++i) {
		  a[i] = dis(rdevs.rng); // generate 10 random number
		                         // according to Cauchy distribution 
		                         // with parameters 0 and 1	   
		}
				   
		rdevs.set_seed(10); // set seed to 10
		
		for(int i = 0; i < 10; ++i) {
		  b[i] = dis(redvs.rng); // generate 10 random number
		                         // according to Cauchy distribution 
		                         // with parameters 0 and 1	   
		}
						      
		rdevs.set_seed_random(); // again seed is random
		
		for(int i = 0; i < 10; ++i) {
		  c[i] = dis(rdevs.rng); // generate 10 random number
		                         // according to Cauchy distribution 
		                         // with parameters 0 and 1	   
		}
			</pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><hr>
	  
	  <h3>Functions</h3>
	  <hr> <br>


	  
	  <a name="is_Hermitian"></a>
	  <b>is_Hermitian(A)<br>is_Hermitian(A, atol, rtol)</b><br><br>
	  <ul>
	    <li> Hermiticity check. Returns <code>true</code> if <code>A</code> is real symmetric or Hermitian, else <code>false</code>.</li><br>

	    <li> <code>atol</code> and <code>rtol</code> are optional, by default <code>atol =  _precision::eps&lt;POD_TYPE&gt;::value</code> and 
	      <code>rtol = 10 * _precision::eps&lt;POD_TYPE&gt;::value</code>. <code>POD_TYPE</code> can be either <code>double</code> or 
	      <code>float</code> depending on the element type of <code>A</code>.</li>
	    
	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><br>
	  



	  <a name="is_Unitary"></a>
	  <b>is_Unitary(A)<br>is_Unitary(A, atol, rtol)</b><br><br>
	  <ul>
	    <li> Unitarity check. Returns <code>true</code> if <code>A</code> is real orthogonal or unitary, else <code>false</code>.</li><br>
	    
	    <li> <code>atol</code> and <code>rtol</code> are optional, by default <code>atol = _precision::eps&lt;POD_TYPE&gt;::value</code> and 
	      <code>rtol = 10 * _precision::eps&lt;POD_TYPE&gt;::value</code>. <code>POD_TYPE</code> is either <code>double</code> or <code>float</code>
	      depending on the element type of <code>A</code>.</li>	    
	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><br>
	  



	  <a name="is_pure"></a>
	  <b>is_pure(A)<br>is_pure(A, check_norm = true)<br>is_pure(A, check_norm, tol)</b><br><br>
	  <ul>
	    <li> Check purity of a row/column vector or density matrix. Returns <code>true</code> if <code>A</code> is a pure state, else <code>false</code>.</li><br>
	    
	    <li> <code>check_norm</code> and <code>tol</code> are optional. By default <code>check_norm = true</code> and normalisation of the state will 
	      be checked and <code>tol = _precision::eps&lt;POD_TYPE&gt;::value</code>, <code>POD_TYPE</code> is either <code>double</code> or 
	      <code>float</code> depending on the element type of <code>A</code>.</li>
	    
	  </ul>
	  <a href="#top">Go to top</a>
	  
	  
	  <hr><br>
	  


	  <a name="is_valid_state"></a>
	  <b>is_valid_state(A)<br>is_valid_state(A, tol)</b><br><br>
	  <ul>
	    <li> Check whether the matrix or vector represents a valid quantum state. Returns <code>true</code> if <code>A</code> is a 
	      valid quantum state, else <code>false</code>.</li><br>
	    
	    <li> <code>tol</code> is optional, by default <code>tol = _precision::eps&lt;POD_TYPE&gt;::value</code>, <code>POD_TYPE</code> is 
	      either <code>double</code> or <code>float</code> depending on the element type of <code>A</code>.</li><br>

	    <li> <b>Note:</b> Normalisation will always be checked.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  
	  
	  <hr><br>



	  <a name="is_diagonalizable"></a>
	  <b>is_diagonalizable(A)</b><br><br>
	  <ul>
	    <li> Check whether the matrix is diagonalizable or not. Returns <code>true</code> if <code>A</code> is diagonalizable, else <code>false</code>.</li><br>
	  </ul>
	  <a href="#top">Go to top</a>
	  
	  
	  <hr><br>



	  <a name=is_equal></a>
	  <b>is_equal(A, B)<br>is_equal(A, B, typecheck = false)<br>is_equal(A, B, typecheck, atol, rtol)</b><br><br>
	  <ul>
	    <li> Check whether two matrices are equal. Returns <code>true</code> if <code>A</code> and <code>B</code> are element-wise equal, 
	      else <code>false</code>.</li><br>
	    
	    <li> <code>typecheck</code> is optional. By default <code>typecheck=false</code>, and element types (<i>complex</i> or <i>real</i>) of 
	      <code>A</code> and <code>B</code> will not be checked.

	    <li> <code>atol</code> and <code>rtol</code> are optional, by default <code>atol = _precision::eps&lt;POD_TYPE&gt;::value</code> and 
	      <code>rtol = 10 * _precision::eps&lt;POD_TYPE&gt;::value</code>. <code>POD_TYPE</code> is either <code>double</code> or <code>float</code>
	      depending on the element type of <code>A</code> or <code>B</code>.</li>	 
	    
	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><br>


	  <a name=range></a>
	  <b>range(stop)<br>range(start, stop)<br>range(start, stop, step)</b><br><br>
	  <ul>
	    <li> Similar to Python's <code>range()</code> function. Useful in range-based <code>for</code> loops. 
	      Returns <code>std::vector</code> of arithmetic (floating point or integral types) values, from (and including) <code>start</code> to 
	      (and excluding) <code>stop</code> with step-size equal to <code>step</code>.</li><br>
	    
	    <li> <code>start</code> and <code>step</code> are optional, by default <code>start = 0</code> and <code>step = 1</code>.</li><br>

	    <li> Example:
	      <pre>
		for(auto&& i : range(10))
		{
		// i from 0 to 9
		//do something
		}
		
		std::vector&lt;int&gt; R1 = range(2, 10, 2); 
		std::vector&lt;double&gt; R2 = range(10, -1.5, -0.5);
	      </pre>
	    </li>

	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><br>




	  <a name=TrX></a>
	  <b>TrX(A, subsys) <br> TrX(A, subsys, dim) </b><br><br>
	  <ul>
	    <li> Partial trace of a quantum state, where <code>subsys</code> is a <code>uvec</code> containing the indices of to be traced out subsystems.</li><br>
	    
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li><br>
	    
	    <li> <code>dim</code> is optional. It can be either <i>unsigned integer</i> type or <code>uvec</code> containing dimensions of every subystem. 
	      When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is <i>2</i>. 
	      If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of every subystem.</li><br>
	    
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and 
	      so on.</li><br>  
	    
	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8, 8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise

		cx_mat B = randn&lt;cx_mat&gt;(12, 12); // 12x12 matrix
		B *= B.t(); // make hermitian
		B /= trace(B); //normalise

                // trace out 2nd and 3rd party
                cx_mat A1 = TrX(A, {2, 3}); // all dim are 2, total 3 parties
		cx_mat A2 = TrX(A, {2, 3}, 2); // same as before

                // trace out 2nd and 3rd party
                cx_mat B1 = TrX(B, {2, 3}, {2, 3, 2}); // explicitly writen dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><br>



	  <a name=Tx></a>
	  <b>Tx(A, subsys) <br> Tx(A, subsys, dim) </b><br><br>
	  <ul>
	    <li> Partial transpose of a quantum state, where <code>subsys</code> is a <code>uvec</code> containing the indices of to 
	      be transposed subsystems.</li><br>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li><br>
	    
	    <li> <code>dim</code> is optional. It can be either <i>unsigned integer</i> type or <code>uvec</code> containing dimensions of every subystem.
	      When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is <i>2</i>. 
	      If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of every subystem.</li><br>
	    
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> 
	      and so on.</li><br>
	    
	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8, 8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise

		cx_mat B = randn&lt;cx_mat&gt;(12, 12); // 12x12 matrix
		B *= B.t(); // make hermitian
		B /= trace(B); //normalise

                // transpose 2nd and 3rd party
                cx_mat A1 = Tx(A, {2, 3}); // all dim are 2, total 3 parties
		cx_mat A2 = Tx(A, {2, 3}, 2); // same as before

                // transpose 2nd and 3rd party
                cx_mat B1 = Tx(B, {2, 3}, {2, 3, 2}); // explicitly writen dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>



	  <a name=sysperm></a>
	  <b>sysperm(A, subsys) <br> sysperm(A, subsys, dim) </b><br><br>
	  <ul>
	    <li> Permute subsystems of a quantum state, where <code>subsys</code> is a <code>uvec</code> containing the permutation of subsystem indices.</li><br>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li><br>
	    
	    <li> <code>dim</code> is optional. It can be either <i>unsigned integer</i> type or <code>uvec</code> containing dimensions of every subystem. 
	      When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is <i>2</i>. 
	      If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of every subystem.</li><br>
	    
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and 
	      so on.</li><br>
	    
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8, 8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise

		cx_mat B = randn&lt;cx_mat&gt;(12, 12); // 12x12 matrix
		B *= B.t(); // make hermitian
		B /= trace(B); //normalise

                // permute 2nd and 3rd party
                cx_mat A1 = sysperm(A, {1, 3, 2}); // all dim are 2, total 3 parties
		cx_mat A2 = sysperm(A, {1, 3, 2}, 2); // same as before

                // permute 2nd and 3rd party
                cx_mat B1 = sysperm(B, {1, 3, 2}, {2, 3, 2}); // explicitly writen dimensions
                // for B1, dim = {2, 2, 3} 
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>



	  <a name=sqrtm_sym></a>
	  <b>sqrtm_sym(A)</b><br><br>
	  <ul>
	    <li>Principal square root of matrix for real symmetric or Hermitian matrices.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Due to generality, always returns <i>complex</i> matrices, even for <i>positive real</i> matrices.</li><br>
	    <li> <b>Note:</b> <code>sqrtm_sym</code> is faster than <code><a href = "#sqrtm_gen">sqrtm_gen</a></code>. For real symmetric or 
	      Hermitian matrices always use
	      <code>sqrtm_sym</code>.</li><br>
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5,5);
		A *= A.t(); // make hermitian
		
		mat B = randn&lt;mat&gt;(5,5);
		B *= B.t(); // make hermitian
		
		cx_mat sqrtA = sqrtm_sym(A);

		cx_mat sqrtB = sqrtm_sym(B);  
  	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>



	  <a name=sqrtm_gen></a>
	  <b>sqrtm_gen(A)</b><br><br>
	  <ul>
	    <li>Principal square root of matrix for general square matrices.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Due to generality, always returns <i>complex</i> matrices, even for <i>positive real</i> matrices.</li><br>
	    <li> <b>Note:</b> <code><a href = "#sqrtm_sym">sqrtm_sym</a></code> is faster than <code>sqrtm_gen</code>. For real symmetric or 
	      Hermitian matrices always use
	      <code><a href = "#sqrtm_sym">sqrtm_sym</a></code>.</li><br>
	    <li> <b>Note:</b> Only works if <code>A</code> is diagonalizable matrix. To make sure, use <code><a href="#is_diagonalizable">is_diagonalizable</a></code>
	      function first.</li><br>
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5,5);
		
		mat B = randn&lt;mat&gt;(5,5);
		
		cx_mat sqrtA = sqrtm_gen(A);

		cx_mat sqrtB = sqrtm_gen(B);  
  	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>



	  <a name=powm_sym></a>
	  <b>powm_sym(A, n)</b><br><br>
	  <ul>
	    <li>Matrix power for real symmetric or Hermitian matrices.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>). <code>n</code> can be any type of scaler, 
	      like <code>double</code>, <code>complex&lt;double&gt;</code>, <code>int</code> etc.</li><br>
	    <li> Due to generality, always returns <i>complex</i> matrices (if <code>n</code> is not <i>integer type</i>), even for <i>positive real</i> matrices.
	      If <code>n</code> is of <i>integer type</i> matrix element type will be preserved.</li><br>
	    <li> <b>Note:</b> <code>powm_sym</code> is faster than <code><a href = "#powm_gen">powm_gen</a></code>. For real symmetric or 
	      Hermitian matrices always use
	      <code>powm_sym</code>.</li><br>
	    <li> Example:

	      <pre>
		mat A = randn&lt;mat&gt;(5, 5);
		A *= A.t(); // make hermitian
		
		mat A_3 = powm_sym(A, 3);

		cx_mat A_3.14 = powm_sym(A, 3.14);  
  	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>


	  <a name=powm_gen></a>
	  <b>powm_gen(A, n)</b><br><br>
	  <ul>
	    <li>Matrix power for general square matrices.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>). <code>n</code> can be any type of scaler, 
	      like <code>double</code>, <code>complex&lt;double&gt;</code>, <code>int</code> etc.</li><br>
	    <li> Due to generality, always returns <i>complex</i> matrices (if <code>n</code> is not <i>integer type</i>), even for <i>positive real</i> matrices.
	      If <code>n</code> is of <i>integer type</i> matrix element type will be preserved.</li><br>
	    <li> <b>Note:</b> <code><a href = "#powm_sym">powm_sym</a></code> is faster than <code>powm_gen</code>. 
	      For real symmetric or Hermitian matrices always use
	      <code><a href = "#powm_sym">powm_sym</a></code>.</li><br>
	    <li> <b>Note:</b> Only works if <code>A</code> is diagonalizable matrix. To make sure, use <code><a href="#is_diagonalizable">is_diagonalizable</a></code>
	      function first.</li><br>
	    <li> Example:

	      <pre>
		mat A = randn&lt;mat&gt;(5, 5);
		
		mat A_3 = powm_gen(A, 3);

		cx_mat A_3.14 = powm_gen(A, 3.14);  
  	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>



	  <a name=expm_sym></a>
	  <b>expm_sym(A)<br>expm_sym(A, n)</b><br><br>
	  <ul>
	    <li>Matrix exponential for real symmetric or Hermitian matrices.<code>expm_sym(A,n)</code> calculates <i>exp(n*A)</i>.</li><br>
	    
	    <li> <code>A</code> has to be a square real symmetric or Hermitian matrix (<code>mat</code> or <code>cx_mat</code>). 
	      <code>n</code> can be any type of scaler, like <code>double</code>, <code>complex&lt;double&gt;</code>, <code>int</code> etc.</li><br>
	    
	    <li> <b>Note:</b> <code>expm_sym</code> is often slower but more accurate than <code><a href = "#expm_gen">expm_gen</a></code> 
	      or <a href="http://arma.sourceforge.net">Armadillo's</a> <code><a href = "http://arma.sourceforge.net/docs.html#expmat">expmat</a></code>. 
	      But for very large matrices it can be faster than the alternatives.</li><br>
	    
	    <li> Example:
	      <pre>
		mat A = randn&lt;mat&gt;(5,  5);
		A *= A.t(); // make hermitian
		
		mat A_e = expm_sym(A);

		complex&lt;double&gt; I (0.0, 1.0);
		cx_mat AI_e = expm_sym(A, I);
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>







	  <hr><br>



	  <a name="expm_gen"></a>
	  <b>expm_gen(A)</b><br><br>
	  <ul>
	    <li>Matrix exponential for general square matrices.    </li><br>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>). </li><br>
	    
	    <li> <b>Note:</b> <code>expm_gen</code> is basically same as <a href="http://arma.sourceforge.net">Armadillo's</a> 
	      <code><a href = "http://arma.sourceforge.net/docs.html#expmat">expmat</a></code>, and only to be used with older 
	      versions of <a href="http://arma.sourceforge.net">Armadillo</a>. </li><br>
	    
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5, 5);
		
		cx_mat A_e = expm_gen(A);

		complex&lt;double&gt; I (0.0, 1.0);
		cx_mat AI_e = expm_gen(I*A);
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>



	  <a name=funcm_sym></a>
	  <b>funcm_sym(A, function pointer)<br>funcm_sym(A, functor)<br>funcm_sym(A, lambda function)</b><br><br>
	  <ul>
	    
	    <li><a href = "https://en.wikipedia.org/wiki/Matrix_function">Matrix function</a> for real symmetric or Hermitian matrices.   </li><br>
	    
	    <li> <code>A</code> has to be a square real symmetric or Hermitian matrix (<code>mat</code> or <code>cx_mat</code>). 
	      <i>function pointer</i>, <i>functor</i> or <i>lambda function</i> has to take one <i>complex</i> type and return one <i>complex</i> type.</li><br>
	    
	    <li> If you want to use standard <i>complex</i> functions, use static member functions of <code><a href="#func">Func&lt;type&gt;</a></code> 
	      class.</li><br>
	    
	    <li> <b>Note:</b> <code>funcm_sym</code> is faster than <code><a href = "#funcm_gen">funcm_gen</a></code>. For real symmetric or 
	      Hermitian matrices always use <code>funcm_sym</code>. </li><br>
	    
	    <li> <b>Note:</b> If you want to transform the matrix element-wise, use 
	      <code><a href="http://arma.sourceforge.net/docs.html#transform">.transform</a></code> instead.</li><br>
	    
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5, 5);
		A *= A.t(); // make hermitian
		
		//define a lambda function
		auto sinm = [](complex&lt;double&gt; a){return std::sin(a);};

		cx_mat A_sin = funcm_sym(A, sinm); // calculate sin(A)

		cx_mat A_sin2 = funcm_sym(A, func::sin); // same as A_sin, 
		//using <code>Func&lt;type&gt;</code> class
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr><br>



	  <a name="funcm_gen"></a>
	  <b>funcm_gen(A, function pointer)<br>funcm_gen(A, functor)<br>funcm_gen(A, lambda function)</b><br><br>
	  <ul>
	    
	    <li><a href = "https://en.wikipedia.org/wiki/Matrix_function">Matrix function</a> for general square matrices.   </li><br>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>). <i>function pointer</i>, 
	      <i>functor</i> or <i>lambda function</i> has to take one <i>complex</i> type and return one <i>complex</i> type.</li><br>
	    
	    <li> If you want to use standard <i>complex</i> functions, use static member functions of <code><a href="#func">Func&lt;type&gt;</a></code> 
	      class.</li><br>
	    
	    <li> <b>Note:</b> <code><a href = "#funcm_sym">funcm_sym</a></code> is faster than <code>funcm_gen</code>. For real symmetric or Hermitian 
	      matrices always use <code><a href = "#funcm_sym">funcm_sym</a></code>.</li><br>

	    <li> <b>Note:</b> Only works if <code>A</code> is diagonalizable matrix. To make sure, use <code><a href="#is_diagonalizable">is_diagonalizable</a></code>
	      function first.</li><br>	    

	    <li> <b>Note:</b> If you want to transform the matrix element-wise, use 
	      <code><a href="http://arma.sourceforge.net/docs.html#transform">.transform</a></code> instead.</li><br>
	    

	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5, 5);
		
		//define a lambda function
		auto sinm = [](complex&lt;double&gt; a){return std::sin(a);}; 

		cx_mat A_sin = funcm_gen(A, sinm); // calculate sin(A)

		cx_mat A_sin2 = funcm_gen(A, func::sin); // same as A_sin, 
		// using <code>Func&lt;type&gt;</code> class
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>


	  <a name=tensor></a>
	  <b>tensor(A, B, ...)</b><br><br>
	  <ul>
	    <li>Tensor product of arbitrary no. of matrices <code>A,B,...</code>.   </li><br>
	    <li> Can also take <code>std::vector</code> and <code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> of matrices.</li><br>
	    
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5, 5); //complex matrix
		cx_mat B = randn&lt;cx_mat&gt;(4, 4); //complex matrix
		cx_mat C = randn&lt;cx_mat&gt;(3, 3); //complex matrix
		mat D = randn&lt;mat&gt;(6, 6); //real matrix
		
		cx_mat T1 = tensor(A, B, C, D); // tensor product of A,B,C,D 

		std::vector&lt;cx_mat&gt; V = {A, B, C};
		cx_mat T2 = tensor(V); // tensor product of A,B,C
		
		cx_mat T3 = tensor({A, B, C}); // same as above  
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>


	  <a name=tensor_pow></a>
	  <b>tensor_pow(A, n)</b><br><br>
	  <ul>
	    <li>Tensor product power of a matrix.   </li><br>
	    <li>Returns <i>A <sup>&otimes;n</sup></i> .</li>
	    
	  </ul>
	  <a href="#top">Go to top</a>







	  
	  <hr><br>


	  <a name=dsum></a>
	  <b>dsum(A, B, ...)</b><br><br>
	  <ul>
	    <li>Direct sum of arbitrary no. of matrices <code>A,B,...</code>.   </li><br>
	    <li> Can also take <code>std::vector</code> and <code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> of matrices.</li><br>
	    
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5, 5); 
		cx_mat B = randn&lt;cx_mat&gt;(4, 4); 
		cx_mat C = randn&lt;cx_mat&gt;(3, 3); 
		cx_mat D = randn&lt;cx_mat&gt;(6, 6); 
		
		cx_mat T1 = dsum(A, B, C, D);  

		std::vector&lt;cx_mat&gt; V = {A, B, C, D};
		cx_mat T2 = dsum(V); 
		
		cx_mat T3 = dsum({A, B, C});  
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>


	  <a name=dsum_pow></a>
	  <b>dsum_pow(A, n)</b><br><br>
	  <ul>
	    <li>Direct sum power of a matrix.   </li><br>
	    <li>Returns <i>A <sup>&oplus;n</sup></i> .</li>
	    
	  </ul>
	  <a href="#top">Go to top</a>
















	  <hr><br>


	  <a name=absm></a>
	  <b>absm(A)</b><br><br>
	  <ul>
	    <li>Matrix absolute value of a square matrix.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li>Returns <code>sqrtm_sym(rho.t()*rho)</code>.</li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>


	  <a name=schatten></a>
	  <b>schatten(A, p)</b><br><br>
	  <ul>
	    <li>Schatten p-norm of a matrix.</li><br>
	    <li> <code>p</code> has to be greater than or equal to <i>0</i>.</li><br>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>


	  <a name="purify"></a>
	  <b>purify(rho)<br>purify(rho, tol)</b><br><br>
	  <ul>
	    <li>Returns (<code>vec</code> or <code>cx_vec</code>) a minimal purification of a density matrix.</li><br>
	    <li> <code>tol</code> is optional. By default, it defined by <code><a href="#eps">_precision::eps</a></code>. Eigenvalues less than <code>tol</code> 
	      are taken to be zero.</li><br>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>


	  <a name="conv_to_pure"></a>
	  <b>conv_to_pure(A)</b><br><br>
	  <ul>
	    <li>Convert density matrix of a pure state to a column vector.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector 
	      (<code>vec</code> or <code>cx_vec</code>).</li><br>
	    <li> If <code>A</code> is a column vector, then it is returned back. </li><br>
	    <li> If <code>A</code> is not a pure state, then eigenvector corresponding to highest eigenvalue is returned. 
	      To make sure use <code><a href="#is_pure">is_pure</a></code> function first.</li><br>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>


	  <a name="std_to_HS"></a>
	  <b>std_to_HS(A)</b><br><br>
	  <ul>
	    <li>Convert 2-qubit density matrix from the standard basis to the Hilbert-Schmidt basis.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) of 4x4.</li><br>
	    <li> Always returns a real matrix.</li><br>
	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><br>


	  <a name="HS_to_std"></a>
	  <b>HS_to_std(A)</b><br><br>
	  <ul>
	    <li>Convert 2-qubit density matrix from the Hilbert-Schmidt basis to the standard basis.</li><br>
	    <li> <code>A</code> has to be a real square matrix (<code>mat</code>) of 4x4.</li><br>
	    <li> Always returns a complex matrix.</li><br>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr><br>


	  <a name=mket></a>
	  <b>mket(mask) <br>
	    mket&lt;ELEMENT_TYPE&gt;(mask) <br> 
	    mket(mask, dim) <br>
	    mket&lt;ELEMENT_TYPE&gt;(mask, dim)</b><br><br>
	  <ul>
	    <li>Create multipartite qudit pure state according to <i>mask</i> <code>uvec</code> (See following example).</li><br>
	    <li> <code>ELEMENT_TYPE</code> is optional, by default it is <code>complex&lt;double&gt;</code>. It specifies the element type of 
	      returned column vector.</li><br>
	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. 
	      When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is 
	      <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of 
	      every subystem.</li><br>
	    <li>Example:
	      <pre>
		cx_vec A = mket({0, 0, 1}); // |001&gt; state
		// each subsystem is qubit

		vec B = mket&lt;double&gt;({0, 0, 1}); // same a above
		// but real vector returned
		
		vec C = mket&lt;double&gt;({0, 0, 1}, 2); // same a above
		
		cx_vec D = mket({0, 2, 1}, {2, 3, 2}); //|021&gt; state
		// 1st and 3rd party are qubit
		// 2nd one is qutrit

		vec E = mket&lt;double&gt;({0, 2, 1},{2, 3, 2}); //same as above
		// but real vector returned
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>


	  <a name=mproj></a>
	  <b>mproj(mask) <br>
	    mproj&lt;ELEMENT_TYPE&gt;(mask) <br> 
	    mproj(mask, dim) <br>
	    mproj&lt;ELEMENT_TYPE&gt;(mask, dim)</b><br><br>
	  <ul>
	    <li>Create multipartite qudit projectors to <i>mask</i> <code>uvec</code> (See following example).</li><br>
	    <li> <code>ELEMENT_TYPE</code> is optional, by default it is <code>complex&lt;double&gt;</code>. It specifies the element type of 
	      returned matrix.</li><br>
	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. 
	      When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is 
	      <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of 
	      every subystem.</li><br>
	    <li>Example:
	      <pre>
		cx_mat A = mproj({0, 0, 1}); // |001&gt;&lt;001| projector
		// each subsystem is qubit

		mat B = mproj&lt;double&gt;({0, 0, 1}); // same a above
		// but real matrix returned
		
		mat C = mproj&lt;double&gt;({0, 0, 1}, 2); // same a above
		
		cx_mat D = mproj({0, 2, 1}, {2, 3, 2}); //|021&gt;&lt;021| projector
		// 1st and 3rd party are qubit
		// 2nd one is qutrit

		mat E = mproj&lt;double&gt;({0, 2, 1}, {2, 3, 2}); //same as above
		// but real matrix returned
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>








	  <hr><br>


	  <a name=randU></a>
	  <b>randU&lt;TYPE = double&gt;(range = {0, 1}) <br>
	    randU&lt;VEC_TYPE = vec&gt;(n_elem, range = {0, 1}) <br>
	    randU&lt;MAT_TYPE = mat&gt;(n_rows, n_cols, range = {0, 1})
	  </b><br><br>
	  <ul>
	    <li>Generate object with uniform random values in the range specified by the <i>column vector</i> <code>range</code>. By default the range is 
	      in between <code>0</code> to <code>1</code>.</li><br>

	    <li> The first function generate only one random element of type (<i>real</i> or <i>complex</i>) specified by <code>TYPE</code>. By 
	      default <code>TYPE</code> is <code>double</code>.</li><br>

	    <li> The second function generate a row or column vector of type (with <i>real</i> or <i>complex</i> elements) specified by 
	      <code>VEC_TYPE</code>, with <code>n_elem</code> number of elements. By default <code>VEC_TYPE</code> is <code>vec</code>.</li><br>


	    <li> The third function generate a matrix of type (with <i>real</i> or <i>complex</i> elements) specified by 
	      <code>MAT_TYPE</code>, with <code>n_rows</code> number of rows, <code>n_cols</code> number of columns. 
	      By default <code>MAT_TYPE</code> is <code>mat</code>.</li><br>

	    <li> To change the seed of the random number generator, use <code>rdevs.set_seed(YOUR_SEED)</code>. To set random seed use 
	      <code>rdevs.set_seed_random()</code>. By default, the random number generator is instantiated with random seed. See 
	      <code><a href="#RandomDevices">RandomDevices</a></code> class for more details.</li><br>


	    <li>Example:
	      <pre>
		double a = randU(); // random number between 0 and 1
		
		complex&lt;double&gt; b = randU&lt;complex&lt;double&gt; &gt;(); 
		// complex random number between (0,0) and (1,1)
		
		double c = randU({-5, 5}); // random number between -5 and 5
		
		cx_vec V = randU&lt;cx_vec&gt;(10); // cx_vec with 10 elements 

		cx_rowvec R = randU&lt;cx_rowvec&gt;(10, {-5, 5}); // cx_rowvec with 10 elements

		mat M1 = randU(10, 10); // 10x10 mat

		mat M2 = randU(10, 10, {-5, 5}); // 10x10 mat  

		cx_mat M3 = randU&lt;cx_mat&gt;(10, 10, {-5, 5}); // 10x10 cx_mat  
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>












	  <hr><br>


	  <a name=randN></a>
	  <b>randN&lt;TYPE = double&gt;(meansd = {0, 1}) <br>
	    randN&lt;VEC_TYPE = vec&gt;(n_elem, meansd = {0, 1}) <br>
	    randN&lt;MAT_TYPE = mat&gt;(n_rows, n_cols, meansd = {0, 1})
	  </b><br><br>
	  <ul>
	    <li>Generate object with random values from normal distribution with mean and standard deviation specified by the 
	      <i>column vector</i> <code>range</code>. By default the mean and standard deviation are <code>0</code> and <code>1</code> respectively.</li><br>

	    <li> The first function generate only one random element of type (<i>real</i> or <i>complex</i>) specified by <code>TYPE</code>. By 
	      default <code>TYPE</code> is <code>double</code>.</li><br>

	    <li> The second function generate a row or column vector of type (with <i>real</i> or <i>complex</i> elements) specified by 
	      <code>VEC_TYPE</code>, with <code>n_elem</code> number of elements. By default <code>VEC_TYPE</code> is <code>vec</code>.</li><br>


	    <li> The third function generate a matrix of type (with <i>real</i> or <i>complex</i> elements) specified by 
	      <code>MAT_TYPE</code>, with <code>n_rows</code> number of rows, <code>n_cols</code> number of columns. 
	      By default <code>MAT_TYPE</code> is <code>mat</code>.</li><br>

	    <li> To change the seed of the random number generator, use <code>rdevs.set_seed(YOUR_SEED)</code>. To set random seed use 
	      <code>rdevs.set_seed_random()</code>. By default, the random number generator is instantiated with random seed. See 
	      <code><a href="#RandomDevices">RandomDevices</a></code> class for more details.</li><br>


	    <li>Example:
	      <pre>
		double a = randN(); 
		// random number from a normal distribution with mean 0 and sd 1
		
		complex&lt;double&gt; b = randN&lt;complex&lt;double&gt; &gt;(); 
		// complex random number from a normal distribution with mean 0 and sd 1
		
		double c = randN({-5, 5}); 
		// random number from a normal distribution with mean -5 and sd 5
		
		cx_vec V = randN&lt;cx_vec&gt;(10); // cx_vec with 10 elements 

		cx_rowvec R = randN&lt;cx_rowvec&gt;(10, {-5, 5}); // cx_rowvec with 10 elements

		mat M1 = randN(10, 10); // 10x10 mat

		mat M2 = randN(10, 10, {-5, 5}); // 10x10 mat  

		cx_mat M3 = randN&lt;cx_mat&gt;(10, 10, {-5, 5}); // 10x10 cx_mat  
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>








	  <hr><br>


	  <a name=randI></a>
	  <b>randI&lt;TYPE = int&gt;(range = {0, 1000}) <br>
	    randI&lt;VEC_TYPE = ivec&gt;(n_elem, range = {0, 1000}) <br>
	    randI&lt;MAT_TYPE = imat&gt;(n_rows, n_cols, range = {0, 1000})
	  </b><br><br>
	  <ul>
	    <li>Generate object with uniform random integers in the range specified by the <i>column vector</i> <code>range</code>. By default the range is 
	      in between <code>0</code> to <code>1</code>.</li><br>

	    <li> The first function generate only one random integer of type (<i>real</i> or <i>complex</i>) specified by <code>TYPE</code>. By 
	      default <code>TYPE</code> is <code>int</code>.</li><br>

	    <li> The second function generate a row or column vector of type (with <i>real</i> or <i>complex</i> elements) specified by 
	      <code>VEC_TYPE</code>, with <code>n_elem</code> number of elements. By default <code>VEC_TYPE</code> is <code>ivec</code>.</li><br>


	    <li> The third function generate a matrix of type (with <i>real</i> or <i>complex</i> elements) specified by 
	      <code>MAT_TYPE</code>, with <code>n_rows</code> number of rows, <code>n_cols</code> number of columns. 
	      By default <code>MAT_TYPE</code> is <code>imat</code>.</li><br>

	    <li> To change the seed of the random number generator, use <code>rdevs.set_seed(YOUR_SEED)</code>. To set random seed use 
	      <code>rdevs.set_seed_random()</code>. By default, the random number generator is instantiated with random seed. See 
	      <code><a href="#RandomDevices">RandomDevices</a></code> class for more details.</li><br>


	    <li>Example:
	      <pre>
		int a = randI(); // random integer between 0 and 10000
		
		complex&lt;double&gt; b = randI&lt;complex&lt;double&gt; &gt;(); 
		// complex random integer (typecasted to double) between (0,0) and (1000,1000)
		
		int c = randI({-100, 100}); // random integer between -100 and 100
		
		ivec V = randI(10); // ivec with 10 elements 

		irowvec R = randI&lt;irowvec&gt;(10, {-100, 100}); // irowvec with 10 elements

		imat M1 = randI(10, 10); // 10x10 imat

		mat M2 = randI&lt;mat&gt;(10, 10, {-100, 100}); // 10x10 mat  
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>








	  <hr><br>


	  <a name=randHermitian></a>
	  <b>randHermitian&lt;ELEM_TYPE = complex&lt;double&gt; &gt;(dim)
	  </b><br><br>
	  <ul>
	    <li>Generate random Hermitian matrix <code>cx_mat</code>. 
	      <code>dim</code> is an <i>unsigned integer</i> type specifying the dimension of the matrix.</li><br>

	    <li> <code>ELEM_TYPE</code> specifies the element type of the matrix (<i>complex floating point</i> type). By default it is 
	      <code>complex&lt;double&gt</code>.</li><br>

	    <li> To change the seed of the random number generator, use <code>rdevs.set_seed(YOUR_SEED)</code>. To set random seed use 
	      <code>rdevs.set_seed_random()</code>. By default, the random number generator is instantiated with random seed. See 
	      <code><a href="#RandomDevices">RandomDevices</a></code> class for more details.</li><br>


	    <li>Example:
	      <pre>
		cx_mat H1 = randHermitian(10); // 10x10 Hermitian cx_mat

		cx_fmat H2 = randHermitian&lt;complex&lt;float&gt; &gt;(10); // 10x10 Hermitian cx_fmat
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>


	  <a name=randUnitary></a>
	  <b>randUnitary&lt;ELEM_TYPE = complex&lt;double&gt; &gt;(dim)
	  </b><br><br>
	  <ul>
	    <li>Generate random Unitary matrix <code>cx_mat</code>, uniformly distributed according to the Haar measure.
	      <code>dim</code> is an <i>unsigned integer</i> type specifying the dimension of the matrix.</li><br>

	    <li> <code>ELEM_TYPE</code> specifies the element type of the matrix (<i>complex floating point</i> type). By default it is 
	      <code>complex&lt;double&gt</code>.</li><br>

	    <li> To change the seed of the random number generator, use <code>rdevs.set_seed(YOUR_SEED)</code>. To set random seed use 
	      <code>rdevs.set_seed_random()</code>. By default, the random number generator is instantiated with random seed. See 
	      <code><a href="#RandomDevices">RandomDevices</a></code> class for more details.</li><br>


	    <li>Example:
	      <pre>
		cx_mat U1 = randUnitary(10); // 10x10 Unitary cx_mat

		cx_fmat U2 = randUnitary&lt;complex&lt;float&gt; &gt;(10); // 10x10 Unitary cx_fmat
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>



	  <a name=randPsi></a>
	  <b>randPsi&lt;ELEM_TYPE = complex&lt;double&gt; &gt;(dim)
	  </b><br><br>
	  <ul>
	    <li>Generate random pure states <code>cx_vec</code>, uniformly distributed according to the Haar measure.
	      <code>dim</code> is an <i>unsigned integer</i> type specifying the dimension of the state.</li><br>

	    <li> <code>ELEM_TYPE</code> specifies the element type of the matrix (<i>complex floating point</i> type). By default it is 
	      <code>complex&lt;double&gt</code>.</li><br>

	    <li> To change the seed of the random number generator, use <code>rdevs.set_seed(YOUR_SEED)</code>. To set random seed use 
	      <code>rdevs.set_seed_random()</code>. By default, the random number generator is instantiated with random seed. See 
	      <code><a href="#RandomDevices">RandomDevices</a></code> class for more details.</li><br>


	    <li>Example:
	      <pre>
		cx_vec psi1 = randPsi(10); // pure state (cx_vec) of dimension 10

		cx_fvec psi2 = randPsi&lt;complex&lt;float&gt; &gt;(10); // pure state (cx_fvec) of dimension 10
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>










	  <hr><br>


	  <a name=entropy></a>
	  <b>entropy(A)</b><br><br>
	  <ul>
	    <li>von Neumann entropy of a quantum state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector 
	      (<code>vec</code> or <code>cx_vec</code>).</li><br>
	    <li> If <code>A</code> is a column vector, then always zero is returned. </li>
	  </ul>
	  <a href="#top">Go to top</a>







	  <hr><br>


	  <a name=shannon></a>
	  <b>shannon(V)</b><br><br>
	  <ul>
	    <li>Shannon entropy of a probability distribution.</li><br>
	    <li> <code>V</code>  has to be a positive real column vector (<code>vec</code>) or <code>std::vector</code> of positive real numbers.</li>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr><br>




	  <a name=renyi></a>
	  <b>renyi(A, a)</b><br><br>
	  <ul>
	    <li>Renyi entropy of a quantum state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector 
	      (<code>vec</code> or <code>cx_vec</code>), and <code>a</code> has to to greater than or equal to zero.</li><br>
	    <li> If <code>A</code> is a column vector, then always zero is returned. </li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>


	  <a name=renyi_prob></a>
	  <b>renyi_prob(V, a)</b><br><br>
	  <ul>
	    <li>Renyi entropy of a probability distribution.</li><br>
	    <li> <code>V</code>  has to be a positive real column vector (<code>vec</code>) or <code>std::vector</code> of positive 
	      real numbers, and <code>a</code> has to to greater than or equal to zero.</li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>




	  <a name=tsallis></a>
	  <b>tsallis(A, a)</b><br><br>
	  <ul>
	    <li>Tsallis entropy of a quantum state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector 
	      (<code>vec</code> or <code>cx_vec</code>), and <code>a</code> has to to greater than or equal to zero.</li><br>
	    <li> If <code>A</code> is a column vector, then always zero is returned. </li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>


	  <a name="tsallis_prob"></a>
	  <b>tsallis_prob(V, a)</b><br><br>
	  <ul>
	    <li>Tsallis entropy of a probability distribution.</li><br>
	    <li> <code>V</code>  has to be a positive real column vector (<code>vec</code>) or <code>std::vector</code> of positive 
	      real numbers, and <code>a</code> has to to greater than or equal to zero.</li>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr><br>



	  <a name=mutual_info></a>
	  <b>mutual_info(A, dim) <br> 
	    mutual_info(A, subsys1, subsys2)<br> 
	    mutual_info(A, subsys1, subsys2, dim)</b><br><br>
	  <ul>
	    <li> Quantum mutual information between 2 subsystems of a quantum state.</li><br>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector 
	      (<code>vec</code> or <code>cx_vec</code>).</li><br>

	    <li> In the first case, <code>dim</code> has to be a <code>uvec</code> of two elements, containing the dimensions of two subsystems.</li><br>

	    <li> In the second case, <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> 
	      containing dimensions of every subystem. When it is unsigned integer type, all sybsystems are supposed to have same dimensions 
	      (equal to <code>dim</code>). By default it is <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> 
	      as a <code>uvec</code> containing dimensions of every subystem.
	      <code>subsys1</code> and <code>subsys1</code> are  <code>uvec</code> containing the indices of 1st party and 2nd party respectively.

	    </li><br>
	    <li> Indices in <code>subsys1</code> and <code>subsys2</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, 
	      second party has the index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		
		cx_mat A = randRho(12); // 12x12 density matrix
		
		cx_mat B = randRho(16); // 16x16 density matrix

		// mutual_info between two parties with dim 4 and 3
		double A1 = mutual_info(A, {4, 3}); // 1st party has dim=4,
		// 2nd party has dim=3

		// mutual_info between 1,3 and 2,4 parties
		double B1 = mutual_info(B, {1, 3}, {2, 4});

		double B2 = mutual_info(B, {1, 3}, {2, 4}, 2); //same as above
		// all party has dim = 2

		double B1 = mutual_info(B, {1, 3}, {2, 4}, {2, 2, 2, 2}); 
		// explicitly writen dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>










	  <hr><br>




	  <a name=entanglement></a>
	  <b>entanglement(A, dim)</b><br><br>
	  <ul>
	    <li>Entanglement entropy of a pure quantum state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector 
	      (<code>vec</code> or <code>cx_vec</code>), and <code>dim</code> has to be a <code>uvec</code> of two elements, 
	      containing the dimensions of two subsystems..</li><br>
	    <li> If <code>A</code> is a square matrix and not a density matrix of a pure state, then von Neumann entropy of traced out 
	      2nd party density matrix is returned. To make sure use <code><a href="#is_pure">is_pure</a></code> function first. </li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>




	  <a name=neg></a>
	  <b>neg(A, subsys) <br> neg(A, subsys, dim) </b><br><br>
	  <ul>
	    <li> Negativity of a quantum state, where <code>subsys</code> is a <code>uvec</code> containing the indices of transposed subsystems.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li><br>
	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. 
	      When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). 
	      By default it is <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> 
	      containing dimensions of every subystem.</li><br>
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the 
	      index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randRho(8); // 8x8 density matrix
		
		cx_mat B = randRho(12); // 12x12 density matrix
		
		// negativity by transposing 2nd and 3rd party
		double A1 = neg(A, {2, 3}); // all dim are 2, total 3 parties

		// negativity by transposing 2nd and 3rd party
		double B1 = neg(B, {2, 3}, {2, 3, 2}); // explicitly writen dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr><br>




	  <a name=log_neg></a>
	  <b>log_neg(A, subsys) <br> log_neg(A, subsys, dim) </b><br><br>
	  <ul>
	    <li> Logarithmic negativity of a quantum state, where <code>subsys</code> is a <code>uvec</code> containing the indices 
	      of transposed subsystems.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li><br>
	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. 
	      When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is 
	      <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions 
	      of every subystem.</li><br>
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index 
	      <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randRho(8); // 8x8 density matrix

		cx_mat B = randRho(12); // 12x12 density matrix

		// logarithmic negativity by transposing 2nd and 3rd party
		double A1 = log_neg(A, {2, 3}); // all dim are 2, total 3 parties

		// logarithmic negativity by transposing 2nd and 3rd party
		double B1 = log_neg(B, {2, 3}, {2, 3, 2}); // explicitly writen dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr><br>




	  <a name=concurrence></a>
	  <b>concurrence(A) </b><br><br>
	  <ul>
	    <li> Concurrence of a two-qubit quantum state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) of dimension 4.</li>
	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><br>


	  <a name=EoF></a>
	  <b>EoF(A) </b><br><br>
	  <ul>
	    <li> Entanglement of formation of a two-qubit quantum state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or column vector  
	      (<code>vec</code> or <code>cx_vec</code>) of dimension 4.</li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>


	  <a name="ent_check_CMC"></a>
	  <b>ent_check_CMC(A, dim) <br > ent_check_CMC(A, dim1, dim2) </b><br><br>
	  <ul>
	    <li> Check if a bipartite state is entangled or not (based on covariant matrix formulation).</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Returns <code>true</code> if <code>A</code> is entangled, else <code>false</code>. It also can detect large part of bound entangled states.</li><br>
	    <li> The first case assumes both the subsystems have same dimension. <code>dim</code> is an unsigned integer type stating the 
	      dimensions of both the subsystems.</li><br>
	    <li> The second case applies if the subsystems have different  dimensions. <code>dim1</code> and <code>dim2</code> are unsigned 
	      integer types stating the dimensions of 1st and 2nd parties respectively.</li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>


	  <a name="schmidt"></a>
	  <b>vec S = schmidt(A, dim) <br > schmidt(A, dim, S, U, V) </b><br><br>
	  <ul>
	    <li> Schmidt decomposition of a bipartite pure state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li><br>
	    <li> <code>dim</code> is a <code>uvec</code> of two elements, containing dimensions of each party.</li><br>
	    <li> <code>S</code> is a real vector containing Schmidt coefficients. <code>U</code> and <code>V</code> are matrices that 
	      store Schmidt vectors column-wise, such that <code>A = &Sigma;<sub>i</sub> S(i) * kron( U.col(i) , V.col(i) )</code>.</li><br>
	    <li> If <code>A</code> is a square matrix, then it is translated into a column vector using 
	      <code><a href=#conv_to_pure>conv_to_pure</a></code>.</li><br>
	    <li> If decomposition fails then <code>vec S = schmidt(A,dim)</code> throws <code>std::runtime_error</code> exception, 
	      and <code>schmidt(A,dim,S,U,V)</code> returns <code>false</code> and resets <code>S</code>, <code>U</code>, and <code>V</code>.</li><br>
	    <li> Example:
	      <pre>
		cx_mat A = randPsi(8); // 8 dimensional pure state

		vec S1 = schmidt(A, {2, 4});

		vec S;
		cx_mat U,V;
		schmidt(A, {2, 4}, S, U, V);
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>


	  <a name="schmidt_base"></a>
	  <b>schmidtA(A, dim) <br > schmidtA_full(A, dim) <br>
	    schmidtB(A, dim) <br > schmidtB_full(A, dim)<br>
	    schmidtAB(A, dim) <br > schmidtAB_full(A, dim)</b><br><br>
	  <ul>
	    <li> Schmidt vectors of a bipartite pure state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or column vector 
	      (<code>vec</code> or <code>cx_vec</code>).</li><br>
	    <li> <code>dim</code> is a <code>uvec</code> of two elements, containing dimensions of each party.</li><br>
	    <li> If <code>A</code> is a square matrix, then it is translated into a column vector using <code><a href=#conv_to_pure>conv_to_pure</a></code>.</li><br>
	    
	    <li> <code>schmidtA(A,dim)</code> returns truncated Schmidt basis on Alice's side in a column-wise manner, while 
	      <code>schmidtA_full(A,dim)</code> returns full Schmidt basis on Alice's side.</li><br>
	    <li> <code>schmidtB(A,dim)</code> returns truncated Schmidt basis on Bob's side in a column-wise manner, 
	      while <code>schmidtB_full(A,dim)</code> returns full Schmidt basis on Bob's side.</li><br>
	    <li> <code>schmidtAB(A,dim)</code> returns <code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> of 
	      matrices containing truncated Schmidt basis on both sides in a column-wise manner, while <code>schmidtAB_full(A,dim)</code> 
	      returns <code><a href = "http://arma.sourceforge.net/docs.html#field">field</a></code> of matrices containing full Schmidt basis on both side.</li><br>
	    <li> If decomposition fails then these functions throw <code>std::runtime_error</code> exception.</li><br>
	    <li> Example:
	      <pre>
		cx_mat A = randPsi(8); // 8 dimensional pure state
		
		cx_mat V = schmidtB(A, {2, 4}); // V is 4x2 matrix
		
		cx_mat Vf = schmidtB_full(A, {2, 4}); // Vf is 4x4 matrix

		field&lt;cx_mat&gt; AB = schmidtAB(A, {2, 4});
		//AB(0) == Schmidt basis on Alice's side
		//AB(1) == Schmidt basis on Bob's side
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr><br>


	  <a name=HS_dist></a>
	  <b>HS_dist(A, B) </b><br><br>
	  <ul>
	    <li> Hilbert-Schmidt distance between two density matrices.</li><br>
	    <li> <code>A</code> and <code>B</code> have to be square matrices (<code>mat</code> or <code>cx_mat</code>) of same dimension.</li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>


	  <a name=tr_dist></a>
	  <b>tr_dist(A, B) </b><br><br>
	  <ul>
	    <li> Trace distance between two density matrices.</li><br>
	    <li> <code>A</code> and <code>B</code> have to be square matrices (<code>mat</code> or <code>cx_mat</code>) of same dimension.</li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>


	  <a name=bures_dist></a>
	  <b>bures_dist(A, B) </b><br><br>
	  <ul>
	    <li> Bures distance between two density matrices.</li><br>
	    <li> <code>A</code> and <code>B</code> have to be square matrices (<code>mat</code> or <code>cx_mat</code>) of same dimension.</li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>


	  <a name=fidelity></a>
	  <b>fidelity(A, B) </b><br><br>
	  <ul>
	    <li> Fidelity between two density matrices.</li><br>
	    <li> <code>A</code> and <code>B</code> have to be square matrices (<code>mat</code> or <code>cx_mat</code>) of same dimension.</li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>




	  <a name=apply></a>
	  <b>apply(A, U, subsys) <br> apply(A, U, subsys, dim) </b><br><br>
	  <ul>
	    <li>Apply a gate <code>U</code> to a quantum state <code>A</code>, where <code>subsys</code> is a <code>uvec</code> 
	      containing the indices of applicable subsystems.</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li><br>
	    <li> The dimension of gate <code>U</code> must match the dimension of subsystems specified in <code>subsys</code>.</li><br>
	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. 
	      When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). 
	      By default it is <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> 
	      containing dimensions of every subystem.</li><br>
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index 
	      <i>2</i> and so on.</li><br>  
	    <li> <b>Note:</b> Return type is deduced from the element types of <code>rho</code> and <code>U</code>. For simplicity use
	      <code>auto</code> for return type.</li><br>
	    <li> Example:
	      <pre>
		cx_mat A = randRho(8); // 8x8 density matrix

		const cx_mat& U1 = spm.S(1); // \sigma_x gate
		
		cx_mat U2 = kron(spm.S(1),spm.S(1)); 
		// kron(\sigma_x,\sigma_x) gate 

		cx_mat A1 = apply(A, U1, {2}); // all dim are 2, total 3 parties

		cx_mat A2 = apply(A, U2, {1, 3}, {2, 2, 2}); 
		// explicitly writen dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>




	  <a name="apply_ctrl"></a>
	  <b>apply_ctrl(A, U, ctrl, subsys) <br> apply_ctrl(A, U, ctrl, subsys, dim) </b><br><br>
	  <ul>
	    <li>Apply a controlled-gate <code>U</code> to a quantum state <code>A</code>, where <code>subsys</code> is a <code>uvec</code> 
	      containing the indices of applicable subsystems, and <code>ctrl</code> is a <code>uvec</code> containing the indices of control subsystems.</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li><br>
	    <li> The dimension of gate <code>U</code> must match the dimension of subsystems specified in <code>subsys</code>.</li><br>
	    <li> All control subsystems must have same dimensions.</li><br>
	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. 
	      When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is 
	      <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing 
	      dimensions of every subystem.</li><br>
	    <li> Indices in <code>subsys</code> and <code>ctrl</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, 
	      second party has the index <i>2</i> and so on.</li><br>  
	    <li> <b>Note:</b> Return type is deduced from the element types of <code>rho</code> and <code>U</code>. For simplicity use
	      <code>auto</code> for return type.</li><br>
	    <li> Example:
	      <pre>
		cx_mat A = randRho(8); // 8x8 density matrix

		const cx_mat& U1 = spm.S(1); // \sigma_x gate
		
		cx_mat U2 = kron(spm.S(1),spm.S(1)); 
		// kron(\sigma_x,\sigma_x) gate 

		cx_mat A1 = apply_ctrl(A, U1, {1}, {2}); 
		// all dim are 2, total 3 parties

		cx_mat A2 = apply_ctrl(A, U2, {2}, {1, 3}, {2, 2, 2}); 
		// explicitly writen dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><hr>




	  <a name="measure"></a>
	  <b>std::tuple&lt;uword, vec, field&lt;MATRIX_TYPE&gt; &gt; A = measure(cx_mat rho, Ks) <br> 
	    std::tuple&lt;uword, vec, field&lt;MATRIX_TYPE&gt; &gt; A = measure(mat rho, Ks) <br>
	    std::tuple&lt;uword, vec, field&lt;MATRIX_TYPE&gt; &gt; A = measure(cx_mat rho, Ks, subsys, dim)<br> 
	    std::tuple&lt;uword, vec, field&lt;MATRIX_TYPE&gt; &gt; A = measure(mat rho, Ks, subsys, dim)
	  </b>
	  
	  <br><br>
	  <ul>
	    <li>Measure a state <code>rho</code> using a set of Kraus or projection operators <code>Ks</code>. Returns <code>std::tuple</code> 
	      of: 1. result of the measurement (<code><a href = "http://arma.sourceforge.net/docs.html#uword">uword</a></code>), 
	      2. vector of outcome probabilities (<code>vec</code>), 
	      and 3. <code><a href = "http://arma.sourceforge.net/docs.html#field">
		  field</a></code> of post-measurement normalized states (<code>field&lt;cx_mat&gt;</code> or <code>field&lt;mat&gt;</code>).</li><br>

	    <li> <code>rho</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li><br>

	    <li> <code>Ks</code> can be a <code>std::vector</code>, <code>std::initializer_list</code> or a 
	      <code><a href = "http://arma.sourceforge.net/docs.html#field">
		  field</a></code> of Kraus or projection operators (either <code>cx_mat</code>, <code>mat</code>, <code>cx_vec</code> or 
	      <code>vec</code>). It can also be a <code>cx_mat</code> or <code>mat</code>, where each column is treated as projection operators.</li><br>

	    <li> First two functions measure the whole quantum state <code>rho</code>, and the dimension of the operators in <code>Ks</code> 
	      must match the dimension of <code>rho</code>.</li><br>

	    <li> Last two functions partially measure the subsystems of the state <code>rho</code>, where the subsystems are specified in <code>subsys</code>.
	      The dimension of the operators in <code>Ks</code> must match the dimension of subsystems specified in <code>subsys</code>.</li><br>

	    <li> All Kraus or projection operators must have same dimensions.</li><br>

	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. 
	      When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is 
	      <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing 
	      dimensions of every subystem.</li><br>

	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, 
	      second party has the index <i>2</i> and so on.</li><br>  

	    <li> This function will run faster on multi-core machines when OpenMP is enabled in your compiler (eg. <code>-fopenmp</code> in GCC) and
	      <code>QICLIB_PARALLEL</code> macro is defined before including <code>QIClib</code> header.</li><br>

	    <li> <b>Note:</b> <code>MATRIX_TYPE</code> is deduced from the element types of <code>rho</code> and <code>Ks</code>. For simplicity use
	      <code>auto</code> for return type.</li><br>
	    <li> Example:
	      <pre>
		cx_mat rho1 = randRho(2); // 2x2 random density matrix

		std::vector<cx_mat> Ks = {spm.basis2(0,1), spm.basis2(1,1)};
		  // std::vector of projection operators in \sigma_x direction

		  auto A = measure(rho1, Ks); // measurement
		  std::get<0>(A); // measurement result
		    std::get<1>(A); //  outcome probabilities
		      std::get<2>(A); //  post measurement normalised states
			
			cx_mat rho2 = randRho(8); //8x8 random density matrix

			auto B = measure(rho2, Ks, {2}, {2,2,2}); measure the 2nd party
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><hr>




	  <a name="measure_comp"></a>
	  <b>std::tuple&lt;uword, vec&gt; A = measure_comp(rho) <br> 
	    std::tuple&lt;uword, vec&gt; A = measure_comp(rho, subsys, dim) 
	  </b>
	  
	  <br><br>
	  <ul>
	    <li>Measure a state <code>rho</code> in the computational basis. Returns <code>std::tuple</code> 
	      of: 1. result of the measurement (<code><a href = "http://arma.sourceforge.net/docs.html#uword">uword</a></code>) 
	      and 2. vector of outcome probabilities (<code>vec</code>).</li><br>

	    <li> <code>rho</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or 
	      <code>cx_vec</code>).</li><br>

	    <li> The first function measures the whole quantum state, where as the last function partially measures the subsystems of the state 
	      <code>rho</code>, where the subsystems are specified in <code>subsys</code>.</li><br>

	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. 
	      When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is 
	      <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing 
	      dimensions of every subystem.</li><br>

	    <li> This function will run faster on multi-core machines when OpenMP is enabled in your compiler (eg. <code>-fopenmp</code> in GCC) and
	      <code>QICLIB_PARALLEL</code> macro is defined before including <code>QIClib</code> header.</li><br>

	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, 
	      second party has the index <i>2</i> and so on.</li><br>  

	    <li> Example:
	      <pre>
		cx_mat rho1 = randRho(2); // 2x2 random density matrix

		auto A = measure_comp(rho1); // measurement
		std::get<0>(A); // measurement result
		  std::get<1>(A); //  outcome probabilities
		    
		    cx_mat rho2 = randRho(8); //8x8 random density matrix

		    auto B = measure_comp(rho2, {2}, {2,2,2}); measure the 2nd party
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><hr>

	  <h3>Discord like functions</h3>
	  <hr> <br>




	  <a name="discord"></a>
	  <b>discord(A, subsys, dim)</b><br><br>
	  <ul>
	    <li>Quantum discord of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned integer type 
	      containing the index of measured subsystem.</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qubit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> <code>discord</code> returns a <code>vec</code>, where the first term is the value of quantum discord and 2nd and 
	      3rd are optimized values of &theta; and &phi; respectively;</li><br>
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has 
	      the index <i>2</i> and so on.</li><br>
	    <li> <b>Helper functions:</b><br>
	      <code>discord</code> has various helper functions, to fine tune the result. All of these functions have local linkage.<br><br>
	      <ul>
		<li> <code>void set_discord_global(bool a = true)</code> : Set whether global optimization will be performed 
		  (<code>true</code>) or not (<code>false</code>).</li><br>
		<li> <code>void set_discord_global_opt(nlopt::algorithm a = nlopt::GN_DIRECT_L)</code> : Set global optimization algorithm.</li><br>
		<li> <code>void set_discord_global_xtol(double a = 4e-2)</code> : Set global optimization <i>xtol</i>.</li><br>
		<li> <code>void set_discord_global_ftol(double a = 0)</code> : Set global optimization <i>ftol</i>.</li><br>

		<li> <code>void set_discord_local_opt(nlopt::algorithm a = nlopt::LN_COBYLA)</code> : Set local optimization algorithm.</li><br>
		<li> <code>void set_discord_local_xtol(double a = _precision::eps)</code> : Set local optimization <i>xtol</i>.</li><br>
		<li> <code>void set_discord_local_ftol(double a = 0)</code> : Set local optimization <i>ftol</i>.</li><br>

		<li> <code>void set_discord_theta_phi_range(double a = 1,double b = 2)</code>: Set &theta;-&phi; range as multiples of &pi;.</li><br>
		<li> <code>void set_discord_theta_phi_initial(double a = 0.1,double b = 0.1)</code>: Set inital &theta;-&phi; value as multiples of &pi;.</li><br>
		<li> <code>void set_discord_prob_tol(double a = _presicion::eps)</code>: Set floating point presicion for probability calculations.</li>
	      </ul>
	    </li><br>

	    <li> Example:
	      <pre>
		cx_mat A = randRho(8); // 8x8 density matrix

		// change default global optimization algorithm
		set_discord_global_opt(nlopt::GN_DIRECT_L_RAND);

		// change default local optimization algorithm
		set_discord_local_opt(nlopt::LN_SBPLX);

		double disc = discord(A, 2, {2, 2, 2})(0); 
		// measurement is done on 2nd party
		
		double theta = discord(A, 2, {2, 2, 2})(1); //optimized theta value
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>









	  <hr> <br>




	  <a name="discord3"></a>
	  <b>discord3(A, subsys, dim)</b><br><br>
	  <ul>
	    <li>Quantum discord of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned integer type containing the 
	      index of measured subsystem.</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qutrit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party 
	      has the index <i>2</i> and so on.</li><br>  
	    <li> <b>Helper functions:</b><br>
	      <code>discord3</code> has various helper functions, to fine tune the result. All of these functions have local linkage.<br><br>
	      <ul>
		<li> <code>void set_discord3_global(bool a = true)</code> : Set whether global optimization will be performed 
		  (<code>true</code>) or not (<code>false</code>).</li><br>
		<li> <code>void set_discord3_global_opt(nlopt::algorithm a = nlopt::GN_DIRECT_L)</code> : Set global optimization algorithm.</li><br>
		<li> <code>void set_discord3_global_xtol(double a = 0.25)</code> : Set global optimization <i>xtol</i>.</li><br>
		<li> <code>void set_discord3_global_ftol(double a = 0)</code> : Set global optimization <i>ftol</i>.</li><br>

		<li> <code>void set_discord3_local_opt(nlopt::algorithm a = nlopt::LN_COBYLA)</code> : Set local optimization algorithm.</li><br>
		<li> <code>void set_discord3_local_xtol(double a = _precision::eps)</code> : Set local optimization <i>xtol</i>.</li><br>
		<li> <code>void set_discord3_local_ftol(double a = 0)</code> : Set local optimization <i>ftol</i>.</li><br>

		<li> <code>void set_discord3_angle_range(vec a = 2 * ones&lt;vec&gt;(5) )</code>: Set range of angles as multiples of &pi;.</li><br>
		<li> <code>void set_discord3_angle_initial(vec a = 0.1 * ones&lt;vec&gt;(5) )</code>: Set inital values of angles as multiples of &pi;.</li><br>
		<li> <code>void set_discord3_prob_tol(double a = _presicion::eps)</code>: Set floating point presicion for probability calculations.</li>
	      </ul>
	    </li><br>

	    <li> Example:
	      <pre>
		cx_mat A = randRho(18); // 18x18 density matrix
		
		// change default global optimization algorithm
		set_discord3_global_opt(nlopt::GN_DIRECT_L_RAND);

		// change default local optimization algorithm
		set_discord3_local_opt(nlopt::LN_SBPLX);

		double disc = discord3(A, 2, {2, 3, 3}); // measurement is done on 2nd party
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr> <br>






	  <a name=discord_reg></a>
	  <b>discord_reg(A, subsys, dim)</b><br><br>
	  <ul>
	    <li>Constrained regular quantum discord of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned integer 
	      type containing the index of measured subsystem. Here the measurement is only done in the eigenvectors of 3 spin matrices</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qubit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> <code>discord_reg</code> returns a <code>vec</code>, where the 1st element is due to measurement on x direction, 
	      2nd for measurement on y direction and 3rd for measurement on z direction. <code>min</code> of the returned <code>vec</code> 
	      is the actual constrained regular quantum discord.</li><br> 
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the 
	      index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randRho(8); // 8x8 density matrix
		
		vec disc = discord_reg(A, 2, {2, 2, 2}); 
		// measurement is done on 2nd party

		double Cdisk = min(disk); // Constrained regular quantum discord
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>







	  <hr> <br>






	  <a name="discord3_reg"></a>
	  <b>discord3_reg(A, subsys, dim)</b><br><br>
	  <ul>
	    <li>Constrained regular quantum discord of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned 
	      integer type containing the index of measured subsystem. Here the measurement is only done in the eigenvectors of 3 spin matrices</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qutrit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> <code>discord3_reg</code> returns a <code>vec</code>, where the 1st element is due to measurement on x direction, 
	      2nd for measurement on y direction and 3rd for measurement on z direction. <code>min</code> of the returned <code>vec</code> 
	      is the actual constrained regular quantum discord.</li><br> 
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has 
	      the index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randRho(18); // 18x18 density matrix

		vec disc = discord3_reg(A, 2, {2, 3, 3}); 
		// measurement is done on 2nd party

		double Cdisk = min(disk); // Constrained regular quantum discord
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>


































	  <hr> <br>



	  <a name=deficit></a>
	  <b>deficit(A, subsys, dim)</b><br><br>
	  <ul>
	    <li>Quantum work deficit of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned integer type containing the 
	      index of measured subsystem.</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qubit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> <code>deficit</code> returns a <code>vec</code>, where the first term is the value of quantum work deficit and 2nd 
	      and 3rd are optimized values of &theta; and &phi; respectively;</li><br>
	    
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has 
	      the index <i>2</i> and so on.</li><br>  
	    <li> <b>Helper functions:</b><br>
	      <code>deficit</code> has various helper functions, to fine tune the result. All of these functions have local linkage.<br><br>
	      <ul>
		<li> <code>void set_deficit_global(bool a = true)</code> : Set whether global optimization will be 
		  performed (<code>true</code>) or not (<code>false</code>).</li><br>
		<li> <code>void set_deficit_global_opt(nlopt::algorithm a = nlopt::GN_DIRECT_L)</code> : Set global optimization algorithm.</li><br>
		<li> <code>void set_deficit_global_xtol(double a = 4e-2)</code> : Set global optimization <i>xtol</i>.</li><br>
		<li> <code>void set_deficit_global_ftol(double a = 0)</code> : Set global optimization <i>ftol</i>.</li><br>

		<li> <code>void set_deficit_local_opt(nlopt::algorithm a = nlopt::LN_COBYLA)</code> : Set local optimization algorithm.</li><br>
		<li> <code>void set_deficit_local_xtol(double a = _precision::eps)</code> : Set local optimization <i>xtol</i>.</li><br>
		<li> <code>void set_deficit_local_ftol(double a = 0)</code> : Set local optimization <i>ftol</i>.</li><br>

		<li> <code>void set_deficit_theta_phi_range(double a = 1,double b = 2)</code>: Set &theta;-&phi; range as multiples of &pi;.</li><br>
		<li> <code>void set_deficit_theta_phi_initial(double a = 0.1,double b = 0.1)</code>: Set inital &theta;-&phi; value as multiples of &pi;.</li><br>
		<li> <code>void set_deficit_prob_tol(double a = _presicion::eps)</code>: Set floating point presicion for probability calculations.</li>
	      </ul>
	    </li><br>

	    <li> Example:
	      <pre>
		cx_mat A = randRho(8); // 8x8 density matrix
		
		// change default global optimization algorithm
		set_deficit_global_opt(nlopt::GN_DIRECT_L_RAND);

		// change default local optimization algorithm
		set_deficit_local_opt(nlopt::LN_SBPLX);

		double def = deficit(A, 2, {2, 2, 2})(0); 
		// measurement is done on 2nd party

		double theta = deficit(A, 2, {2, 2, 2})(1); 
		// optimized theta value
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>









	  <hr> <br>




	  <a name=deficit3></a>
	  <b>deficit3(A, subsys, dim)</b><br><br>
	  <ul>
	    <li>Quantum work deficit of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned 
	      integer type containing the index of measured subsystem.</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qutrit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, 
	      second party has the index <i>2</i> and so on.</li><br>  
	    <li> <b>Helper functions:</b><br>
	      <code>deficit3</code> has various helper functions, to fine tune the result. All of these functions have local linkage.<br><br>
	      <ul>
		<li> <code>void set_deficit3_global(bool a = true)</code> : Set whether global optimization will be 
		  performed (<code>true</code>) or not (<code>false</code>).</li><br>
		<li> <code>void set_deficit3_global_opt(nlopt::algorithm a = nlopt::GN_DIRECT_L)</code> : Set global optimization algorithm.</li><br>
		<li> <code>void set_deficit3_global_xtol(double a = 0.25)</code> : Set global optimization <i>xtol</i>.</li><br>
		<li> <code>void set_deficit3_global_ftol(double a = 0)</code> : Set global optimization <i>ftol</i>.</li><br>

		<li> <code>void set_deficit3_local_opt(nlopt::algorithm a = nlopt::LN_COBYLA)</code> : Set local optimization algorithm.</li><br>
		<li> <code>void set_deficit3_local_xtol(double a = _precision::eps)</code> : Set local optimization <i>xtol</i>.</li><br>
		<li> <code>void set_deficit3_local_ftol(double a = 0)</code> : Set local optimization <i>ftol</i>.</li><br>

		<li> <code>void set_deficit3_angle_range(vec a = 2 * ones&lt;vec&gt;(5) )</code>: Set range of angles as multiples of &pi;.</li><br>
		<li> <code>void set_deficit3_angle_initial(vec a = 0.1 * ones&lt;vec&gt;(5) )</code>: Set inital values of angles as multiples of &pi;.</li><br>
		<li> <code>void set_deficit3_prob_tol(double a = _presicion::eps)</code>: Set floating point presicion for probability calculations.</li>
	      </ul>
	    </li><br>

	    <li> Example:
	      <pre>
		cx_mat A = randRho(18); // 18x18 density matrix
		
		// change default global optimization algorithm
		set_deficit3_global_opt(nlopt::GN_DIRECT_L_RAND);

		// change default local optimization algorithm
		set_deficit3_local_opt(nlopt::LN_SBPLX);

		double def = deficit3(A, 2, {2, 3, 3}); // measurement is done on 2nd party
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>









	  <hr> <br>






	  <a name=deficit_reg></a>
	  <b>deficit_reg(A, subsys, dim)</b><br><br>
	  <ul>
	    <li>Constrained regular quantum work deficit of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned 
	      integer type containing the index of measured subsystem. Here the measurement is only done in the eigenvectors of 3 spin matrices</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qubit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> <code>deficit_reg</code> returns a <code>vec</code>, where the 1st element is due to measurement on x direction, 
	      2nd for measurement on y direction and 3rd for measurement on z direction. <code>min</code> of the returned <code>vec</code> 
	      is the actual constrained regular quantum work deficit.</li><br> 
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party 
	      has the index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randRho(8); // 8x8 density matrix
		
		vec disc = deficit_reg(A, 2, {2, 2, 2}); 
		// measurement is done on 2nd party

		double Cdisk = min(disk); // Constrained regular quantum work deficit
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>







	  <hr> <br>







	  <a name=deficit3_reg></a>
	  <b>deficit3_reg(A, subsys, dim)</b><br><br>
	  <ul>
	    <li>Constrained regular quantum work deficit of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned 
	      integer type containing the index of measured subsystem. Here the measurement is only done in the eigenvectors of 3 spin matrices</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qutrit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> <code>deficit3_reg</code> returns a <code>vec</code>, where the 1st element is due to measurement on x direction, 
	      2nd for measurement on y direction and 3rd for measurement on z direction. <code>min</code> of the returned <code>vec</code> 
	      is the actual constrained regular quantum work deficit.</li><br> 
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the 
	      index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randRho(18); // 18x18 density matrix
		
		vec disc = deficit3_reg(A, 2, {2, 3, 3}); 
		// measurement is done on 2nd party

		double Cdisk = min(disk); // Constrained regular quantum work deficit
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>












	  <hr><hr>
	  <a name=faq></a>
	  <h3>Frequently asked questions</h3>
	  <hr> <br>

	  <ul>
	    

	    <li> <b> What are the basic dependencies of QIClib?</b><br>
	      <ul>
		<li> <a href="http://arma.sourceforge.net/">Armadillo</a> C++ linear algebra library (<b>version 4.2 or later</b>), with  
		  <a href = "http://www.netlib.org/lapack/">LAPACK</a> and 
		  <a href = "http://www.netlib.org/blas">BLAS</a> implementations.</li>
		<li> A C++11 compliant compiler. <a href="https://gcc.gnu.org/">gcc</a> version 4.8 or later, or 
		  <a href = "http://clang.llvm.org/">clang</a> version 3.3 or later are recommended. </li>
		<li>  <a href="http://ab-initio.mit.edu/wiki/index.php/NLopt">NLopt</a> nonlinear optimization library for 
		  certain features. See <a href ="index.html#getting-started"> getting started</a> section.
	      </ul>
	    </li>

	    <br>

	    
	    <li><b>How do I use QIClib?</b><br>
	      See <a href ="index.html#getting-started"> getting started</a> section.
	    </li>
	    
	    <br>


	    
	    <li><b>How do I report bugs?</b><br>
	      See <a href="index.html#found-an-issue-or-bug">this</a>.
	    </li>
	    
	    <br>


	    <li><b>How do I use XYZ function properly?</b><br>
	      See <a href="#top">API documentation</a>. If you still have concerns, see <a href= "index.html#got-a-problem-or-question">this</a>.
	    </li>
	    
	    <br>


	    <li><b>Can you implement certain features, which are useful for my work?</b><br>
	      Yes, see <a href= "index.html#requesting-a-feature">this</a>.
	    </li>
	    
	    <br>


	    
	    

	    <li> <b> Instead of using other popular C++ linear algebra libraries, why did QIClib choose <a href="http://arma.sourceforge.net/">Armadillo</a>?</b>
	      <ul>
		<li> <a href="http://arma.sourceforge.net/">Armadillo</a> is fast, efficient and reliable.</li>
		<li> It has nice API, which is deliberately similar to Matlab.</li>
		<li> It supports modern C++11 features, like move semantics or initialiser list initialization, which indeed increase efficiency and usability.</li>
		<li> It has rapid developement process.</li>
		<li> It can make use of high performance  multi-threaded <a href = "http://www.netlib.org/lapack/">LAPACK</a> and 
		  <a href = "http://www.netlib.org/blas">BLAS</a> replacements like <a href = "http://www.openblas.net/">OpenBLAS</a>, 
		  <a href = "https://software.intel.com/en-us/intel-mkl">Intel MKL</a>, or 
		  <a href = "http://developer.amd.com/tools-and-sdks/archive/amd-core-math-library-acml/"> AMD ACML</a>.</li>
	      </ul>
	    </li>



	    <br>
	    

	    <li><b>I know C++98, but do not know much about C++11. Can I use QIClib?</b><br>
	      Yes. Though QIClib is written in C++11 standard, you can still do C++98 style coding with QIClib functions. 
	      You just need a C++11 compliant compiler and make sure that you add necessary compiler flag to enable C++11 features, 
	      e.g., in <a href="https://gcc.gnu.org/">gcc</a> or <a href = "http://clang.llvm.org/">clang</a> add <code>-std=c++11</code> flag during compilation.
	    </li>
	    



	    <br>

	    
	    <li><b>Can I use C++11 <code>auto</code> with QIClib functions?</b><br>
	      Though use of C++11 <code>auto</code> is not recommended with <a href="http://arma.sourceforge.net/">Armadillo</a> expressions, 
	      due to the extensive use of template meta-programming, every QIClib functions return by value, so use of <code>auto</code> is safe there. 
	      In fact, use of <code>auto</code> is recommended with QIClib functions and objects, as it will always guarantee <i>move</i> operations. 
	      But again, care should be taken when <code>auto</code> is used with <a href="http://arma.sourceforge.net/">Armadillo</a> expressions. 
	      See the following example:<br>
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8);
		A *= A.t();
		A /= trace(A);

		auto B = A; // OK, no temporary expression
		auto C = TrX(A,{1},{2,2,2}); // OK, QIClib function
		auto D = powm_sym(A,3); // OK, QIClib function

		auto E = A * A; // NOT OK!! temporary expression
		auto F = A + B + D ; // NOT OK!! temporary expression
		auto G = A * A.t(); // NOT OK!! temporary expression

		vec V = {0,1,2,3,4};

		for(auto&& i : V) // OK, no temporary exression
		{
		// do something
		}
		
		for(auto&& i : V+V) // NOT OK!! temporary expression
		{
		// do something
		}

		auto& S1 = spm.S(1); // OK and recommended
		const cx_mat& S2 = spm.S(2); // also OK  
		
	      </pre>
	    </li>


	    
	    <li><b>Do QIClib uses C++14 features?</b><br>
	      No, only C++11 features have been used, since many compilers do not support C++14 fully. C++14 features like <i>auto return 
		type deductions for functions</i> have been avoided by using template meta-programming.
	    </li>
	    
	    <br>



	  </ul>

	  <a href="#top">Go to top</a>



	  <hr><hr>
	  <a name=api_additions></a>
	  <h3>API Additions</h3>
	  <hr> <br>

	  <b>Version 0.0.4</b><br><br>
	  <ul>
	    <li> Added <code><a href="#purify">purify</a></code>,  
	      <code><a href="#std_to_HS">std_to_HS</a></code>, and <code><a href="#HS_to_std">HS_to_std</a></code>.</li>
	    <li> Added <code><a href="#measure">measure</a></code> and <code><a href="#measure_comp">measure_comp</a></code>.</li>
	    <li> Added random number/matrix generators.</li>
	    <li> Added <code><a herf = "#is_diagonalizable">is_diagonalizable</a></code>.
	    <li> Faster <code><a href="#is_equal">is_equal</a></code>, <code><a href="#is_Hermitian">is_Hermitian</a></code>, 
	      <code><a href="#is_Unitary">is_Unitary</a></code>, 
	      <code><a href="#is_pure">is_pure</a></code>, <code><a href="#is_valid_state">is_valid_state</a></code>.
	    <li> Fixed a bug in <a href="#discord_func">discord like functions</a>.</li>
	  </ul>
	  <a href="#top">Go to top</a>

	  <hr><br>

	  <b>Version 0.0.3</b><br><br>
	  <ul>
	    <li> <code><a href="#dsum">dsum</code></a></code> and <code><a href="#dsum_pow">dsum_pow</a></code> added.</li>
<li> Fixed a bug in <code><a href="#tensor">tensor</a></code>.</li>
</ul>
<a href="#top">Go to top</a>

<hr><br>

<b>Version 0.0.2</b><br><br>
<ul>
  <li> <code><a href=#absm>absm</a></code> added.</li>
  <li> <code><a href=#schatten>schatten</a></code> added.</li>
</ul>
<a href="#top">Go to top</a>

<footer class="site-footer">
  <span class="site-footer-owner"><a href="https://github.com/titaschanda/QIClib">Quantum Information and Computation library (QIClib)</a> 
    is maintained by <a href="https://github.com/titaschanda">Titas Chanda</a>.</span>

  <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the 
    <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
</footer>

</section>


</body>
</html>
